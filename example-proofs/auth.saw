enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/auth/target/linked-mir.json";

// Initialize soroban verification with address API
soroban <- soroban_init mod ["address", "storage", "vec_val", "vec_new_from_slice"];


// NOP spec for require_auth
// TODO: Modify this to actually inspect whether the invocation is authorized
let addr_require_auth_spec = do {

  address_obj <- soroban_value_fresh "address_obj" {| Values::AddressObjectT|};
  let address_obj_mir = soroban_value_to_mir soroban.smi address_obj;
  let address = mir_struct_value (soroban.smi.AddressType ()) [soroban.smi.EnvVal(), address_obj_mir];

  self <- mir_alloc (mir_adt (soroban.smi.AddressType ()));
  mir_points_to self address;

  mir_execute_func [
    self
  ];
};

addr_require_auth_ov <- mir_unsafe_assume_spec mod
        "soroban_sdk::address::{impl#9}::require_auth"
        (addr_require_auth_spec);

let auth_spec = do {

  fresh_addr_obj <- soroban_value_fresh "fresh_addr_obj" {| Values::AddressObjectT|};
  let fresh_addr_obj_mir = soroban_value_to_mir soroban.smi fresh_addr_obj;

  value <- mir_fresh_var "value" mir_u32;

  store <- mir_fresh_cryptol_var "store" {| Store::T |};
  heap <- mir_fresh_cryptol_var "hostheap" {| Values::HostHeap |};

  soroban_storage_assert_state store;
  soroban_hostheap_assert_state heap;

  // TODO: Should be passing `fresh_addr_obj` wrapped by an instance of the `Counter` `DataKey` enum variant, not `fresh_obj_addr` itself.
  let user_counter_val = soroban_store_get store fresh_addr_obj {| Values::U32T |};
  count <- option.unwrap {{ Option::unwrap_or user_counter_val (Option::ok Values::u32_zero) }};
  let native_count = {{ Values::u32_to_native count }};

  mir_precond {{ value < 42 }};
  mir_precond {{ native_count < 42 }};

  mir_execute_func [
        soroban.smi.EnvVal (),
        mir_struct_value (soroban.smi.AddressType ()) [soroban.smi.EnvVal(), fresh_addr_obj_mir],
        mir_term value
  ];

  let native_count' = {{ native_count + value }};
  let count' = {{ Values::u32_from_native native_count' }};

  soroban_storage_assert_state (soroban_store_set store fresh_addr_obj count');

  mir_return (mir_term native_count');
};

soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_auth_contract::{impl#4}::increment",
  // Additional overrides
  overrides = [addr_require_auth_ov],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = auth_spec,
  // Prover
  proof = w4
};
