enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/auth/target/linked-mir.json";

// Initialize soroban verification with address API
soroban <- soroban_init mod ["address", "require_auth", "storage", "vec_val", "vec_new_from_slice"];


let auth_spec = do {

  fresh_addr_obj <- soroban_value_fresh "fresh_addr_obj" {| Values::AddressObjectT|};
  let fresh_addr_obj_mir = soroban_value_to_mir soroban.smi fresh_addr_obj;

  value <- mir_fresh_var "value" mir_u32;

  store <- mir_fresh_cryptol_var "store" {| Store::T |};
  heap <- mir_fresh_cryptol_var "hostheap" {| Values::HostHeap |};
  empty_auth <- soroban_auth_fresh ();
  let auth = soroban_declare_authorized empty_auth fresh_addr_obj;

  auth' <- soroban_auth_check_currentargs auth fresh_addr_obj;

  // TODO: Should be passing `fresh_addr_obj` wrapped by an instance of the `Counter` `DataKey` enum variant, not `fresh_obj_addr` itself.
  let user_counter_val = soroban_store_get store fresh_addr_obj {| Values::U32T |};
  count <- option.unwrap {{ Option::unwrap_or user_counter_val (Option::ok Values::u32_zero) }};
  let native_count = {{ Values::u32_to_native count }};

  mir_precond {{ value < 42 }};
  mir_precond {{ native_count < 42 }};

  soroban_storage_assert_state store;
  soroban_hostheap_assert_state heap;
  soroban_auth_assert_state auth;

  mir_execute_func [
        soroban.smi.EnvVal (),
        mir_struct_value (soroban.smi.AddressType ()) [soroban.smi.EnvVal(), fresh_addr_obj_mir],
        mir_term value
  ];

  let native_count' = {{ native_count + value }};
  let count' = {{ Values::u32_from_native native_count' }};

  soroban_storage_assert_state (soroban_store_set store fresh_addr_obj count');
  soroban_auth_assert_state auth';

  mir_return (mir_term native_count');
};

soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_auth_contract::{impl#4}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = auth_spec,
  // Prover
  proof = w4
};
