enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

DataKeyEnum <- cryptol_load "DataKeyEnum.cry";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/auth/target/linked-mir.json";

// Initialize soroban verification with address API
soroban <- soroban_init mod ["address", "require_auth", "storage", "vec_val", "vec_new_from_slice"];

// get a Symbol for the function name
let incrsym = {{ Values::symbol_from_native "increment" }};

// get a Symbol for the rust constructor name
let countersym = {{ Values::symbol_from_native "Counter" }};

let auth_spec = do {

  fresh_addr_obj <- soroban_value_fresh "fresh_addr_obj" {| Values::AddressObjectT|};
  let fresh_addr_obj_mir = soroban_value_to_mir soroban.smi fresh_addr_obj;
  let fresh_addr_obj_raw = {{ Values::addressobj_to_raw fresh_addr_obj }};

  value <- mir_fresh_var "value" mir_u32;
  let value_raw = {{ Values::u32_to_raw (Values::u32_from_native value) }};

  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  heap <- mir_fresh_cryptol_var "hostheap" {| Values::HostHeap |};
  // The heap needs to be able to allocate at least twice.
  mir_assert {{ Values::heap_has_space heap 2 }};

  empty_auth <- soroban_auth_fresh heap incrsym;
  let args = soroban_build_arglist {{ [fresh_addr_obj_raw, value_raw] }};
  let auth = soroban_declare_authorized empty_auth fresh_addr_obj {{ [(incrsym, args)] }};

  auth' <- soroban_auth_check_currentargs heap auth fresh_addr_obj;

  /*
   * We need to allocate two copies of the key because the compiled
   * contract code does so. This seems to be because the conversion to
   * VecObject happens inside each of the two store accesses and it
   * has no way to cache/keep/share the results.
   */

  key <- mir_fresh_cryptol_var "DataKey::Counter" {| (Values::SymbolT, Values::AddressObjectT) |};
  mir_assert {{ Values::symbol_valid key.0 }};
  mir_assert {{ Values::addressobj_valid key.1 }};
  mir_assert {{ Values::symbol_eq key.0 countersym heap }};
  mir_assert {{ Values::addressobj_eq key.1 fresh_addr_obj }};
  let heap'key_vecobj = {{ DataKeyEnum::from_native key heap }};
  let heap' = {{ heap'key_vecobj.0 }};
  let key_vecobj = {{ heap'key_vecobj.1 }};

  key2 <- mir_fresh_cryptol_var "DataKey::Counter2" {| (Values::SymbolT, Values::AddressObjectT) |};
  mir_assert {{ Values::symbol_valid key2.0 }};
  mir_assert {{ Values::addressobj_valid key2.1 }};
  mir_assert {{ Values::symbol_eq key2.0 countersym heap }};
  mir_assert {{ Values::addressobj_eq key2.1 fresh_addr_obj }};
  let heap''key2_vecobj = {{ DataKeyEnum::from_native key2 heap' }};
  let heap'' = {{ heap''key2_vecobj.0 }};
  let key2_vecobj = {{ heap''key2_vecobj.1 }};

  let user_counter_val = soroban_store_get store key_vecobj {| Values::U32T |};
  count <- option.unwrap {{ Option::unwrap_or user_counter_val (Option::ok Values::u32_zero) }};
  let native_count = {{ Values::u32_to_native count }};

  mir_precond {{ value < 42 }};
  mir_precond {{ native_count < 42 }};

  soroban_storage_assert_state store;
  soroban_hostheap_assert_state heap;
  soroban_auth_assert_state auth;

  mir_execute_func [
        soroban.smi.EnvVal (),
        mir_struct_value (soroban.smi.AddressType ()) [soroban.smi.EnvVal(), fresh_addr_obj_mir],
        mir_term value
  ];

  let native_count' = {{ native_count + value }};
  let count' = {{ Values::u32_from_native native_count' }};

  soroban_storage_assert_state (soroban_store_set store key2_vecobj count');
  soroban_hostheap_assert_state heap'';
  soroban_auth_assert_state auth';

  mir_return (mir_term native_count');
};

soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_auth_contract::{impl#4}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = auth_spec,
  // Prover
  proof = w4
};
