enable_experimental;

include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod_a <- mir_load_module "../soroban-examples/cross_contract/contract_a/target/linked-mir.json";
mod_b <- mir_load_module "../soroban-examples/cross_contract/contract_b/target/linked-mir.json";

// Initialize soroban verification
soroban_a <- soroban_init mod_a ["u32_val"];
soroban_b <- soroban_init mod_b ["call", "address_to_contract_id", "vec_new_from_slice", "vec_val", "address", "u32_val"];

// Specification for add in contract A
let add_spec = do {
   // create some args
   x <- mir_fresh_cryptol_var "x" {| [32] |};
   y <- mir_fresh_cryptol_var "y" {| [32] |};

   // compute the result
   let ret = {{ x + y }};

   // precondition is that the addition doesn't overflow
   mir_assert {{ x <= ret }};
   mir_assert {{ y <= ret }};

   mir_execute_func [mir_term x, mir_term y];

   mir_return (mir_term ret);
};

// Specification for add_with in contract B
let add_with_spec = do {
   // need an env
   let env = soroban_b.smi.EnvVal ();

   // get an address and some args
   addrobj <- soroban_value_fresh "addr" {| Values::AddressObjectT |};
   x <- mir_fresh_cryptol_var "x" {| [32] |};
   y <- mir_fresh_cryptol_var "y" {| [32] |};
   let mir_addrobj = soroban_value_to_mir soroban_b.smi addrobj;
   let mir_x = mir_term x;
   let mir_y = mir_term y;
   let sdk_x = {{ Values::u32_from_native x }};
   let sdk_y = {{ Values::u32_from_native x }};

   // the source-level address is a Rust struct that also contains the env
   let addrtype = mir_find_adt mod_b "soroban_sdk::address::Address" [];
   let mir_addr = mir_struct_value addrtype [env, mir_addrobj];

   // establish the precondition that we can add them without overflowing
   let ret = {{ x + y }};
   mir_assert {{ x <= ret }};
   mir_assert {{ y <= ret }};

   // The cross-call mechanism allocates under the covers, so we need a
   // host heap.
   heap <- mir_fresh_cryptol_var "hostheap" {| Values::HostHeap |};

   // The heap needs to be able to allocate at least once.
   mir_assert {{ Values::heap_has_space heap 1 }};

   //
   // What actually happens in the cross-call mechanism in the Rust code:
   //    - Statically the caller creates a contract handle object with
   //      soroban_sdk::contractimport, which is a macro.
   //    - At runtime the caller then calls handle::Client::new() to
   //      make a Client object. Args for that are the Env and the
   //      Address for the contract. That is not part of the import
   //      but an arg to the caller.
   //    - The Client object re-exports the target contract's entry
   //      point methods with their native Rust signatures. (This
   //      is accomplished by macro goop I don't really understand
   //      in derive_client.rs in soroban_sdk_macros.)
   //    - The macro-generated code marshals the arguments and calls
   //      invoke_contract in the Env; this does some conversions and
   //      in turn calls the "call" hypercall.
   //    - invoke_contract is in env.rs in soroban-sdk.
   //    - The args to the "call" hypercall are:
   //         - the Env
   //         - the Address converted to a BytesObject holding the
   //           contract ID
   //         - a Symbol for the function name
   //         - the arguments packed into a VecObject
   //    - The conversions that happen are:
   //         - address to contract ID
   //         - function name string literal to Symbol
   //         - arguments to RawVal
   //         - plus it conses up a VecObj for the arguments.
   //    - It looks as if the arguments also include the Env, but
   //      that can't really be (it can't be a value so can't go in
   //      a VecObj) so I must be missing something there.
   //    - The Env in the Client is a copy of the Env in the caller;
   //      not sure if that's important.
   //    - The return value from the "call" hypercall is a RawVal
   //      holding the result of the callee; this is unpacked on the
   //      way back out.
   //    - Failures at most of these points just panic.
   //
   // In order to model this we need these things in the model layer
   // that we don't already have:
   //    - BytesObject values
   //    - some notion of which Addresses are really contracts and
   //      what their contract IDs are
   //
   // and we need these things we don't already have in the SDK model:
   //    - wrapper goop for BytesObject values
   //    - a way to assert that an Address is a contract with a given
   //      contract ID
   //    - an override spec for the address_to_contract_id hypercall
   //    - an override spec for the call hypercall
   //    - a way to pass fragments of the spec for the target contract
   //      method (in this case contract_a::add) to the override spec
   //      for the call hypercall, such that it can model the result
   //    - plus (though this example doesn't care) we need separate
   //      SDK state for the two contracts, at least for some of the
   //      SDK state elements, and that's a can of worms
   //
   // Right here and now in this spec we need the following:
   //    - a fresh contract ID (a BytesObject of the proper length)
   //    - to assert that the Address we get is a contract with
   //      a contract ID
   //    - a Symbol for the function name ("add")
   //      (although there doesn't seem to be anywhere to put it so
   //      maybe not)
   //    - Soroban-level values for the arguments
   //    - to cons up the args VecObj because it allocates on the heap
   //      and we need to account for that
   //    - fragments of the spec for contract_a to pass to the
   //      spec for the call hypercall, and a way to get them there
   //
   // Also, it looks as if one of the preconditions is that the
   // Address actually points to a contract of the same type / with
   // the same signature / etc. which I think gets checked under the
   // covers but I'm not sure how, nor am I sure how we can reason
   // about it.
   //

   addrstate <- mir_fresh_cryptol_var "addrstate" {| Addresses::T |};
   contractID <- soroban_contractID_fresh "contractID";
   //mir_assert {{ Addresses::valid_contract_id contractID }};
   mir_assert {{ Addresses::have_contract addrstate addrobj contractID }};

   let heap'vec = {{ soroban_value_vecobj_2 sdk_x sdk_y heap }};
   let heap' = {{ heap'vec.0 }};
   let vec = {{ heap'vec.1 }};

   // XXX still need to figure out how to pass in pieces of add_spec

   // bind the initial SDK state
   soroban_addresses_assert_state addrstate;
   soroban_hostheap_assert_state heap;

   // call the function
   mir_execute_func [env, mir_addr, mir_x, mir_y];

   // bind the final SDK state
   soroban_addresses_assert_state addrstate;
   soroban_hostheap_assert_state heap';

   // return the sum
   mir_return (mir_term ret);
};

// Verify add
soroban_verify soroban_a {
   fun = "soroban_cross_contract_a_contract::{impl#1}::add",
   overrides = [],
   path_sat = true,
   spec = add_spec,
   proof = w4
};

// Verify add_with
soroban_verify soroban_b {
   fun = "soroban_cross_contract_b_contract::{impl#1}::add_with",
   overrides = [],
   path_sat = true,
   spec = add_with_spec,
   proof = w4
};
