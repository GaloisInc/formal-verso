enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

Custom <- cryptol_load "CustomTypes.cry";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/custom_types/target/linked-mir.json";

// Initialize soroban verification with storage and symbol APIs
soroban <- soroban_init mod ["storage", "symbol", "u32_val"];

// Compute Symbol value for COUNTER
let COUNTER = {{ Values::symbol_from_native "COUNTER" }};

/*
 * SAW-level operations on the custom type.
 *
 * The Rust representation is a struct with two members (count and
 * last_incr), both u32.
 *
 * The native representation is a pair {| ([32], [32]) |}.
 *
 * The Soroban-level representation is a Values::VecObject::T that
 * points to two Values::U32::T.
 */

/*
 * Get a fresh value.
 *
 * Note: don't make a fresh pair; make two fresh u32s and wrap them in
 * a concrete pair. Otherwise SAW will get upset that the pair wrapper
 * gets thrown away.
 */
let custom_fresh_native name = do {
   count_val <- mir_fresh_cryptol_var (str_concat name ".count") {| [32] |};
   last_val <- mir_fresh_cryptol_var (str_concat name ".last") {| [32] |};
   return {{ (count_val, last_val) }};
};

/*
 * Shared logic to establish a precondition where:
 *    - there is not necessarily a value in the storage
 *    - if there is, it's a VecObject::T
 *         - which points to a vector representation in the host heap
 *         - and which is a valid representation of the custom type
 *
 * Takes a host heap, a store, and a fresh native representation of
 * the custom type value. If there is no value, the fresh var is
 * assigned the default value for the type.
 */
let assert_storage_precond heap store state_native = do {
   // First, check if a state value is set. This controls a bunch of the other logic.
   let has = soroban_store_has store COUNTER;

   // Get value in the store at COUNTER as an Option::T (Option::T (Values::VecObject::T))
   // outer None means there was no value
   // inner None means the value wasn't the right type
   let state_optopt_val = soroban_store_get store COUNTER {| Values::VecObjectT |};

   // First assert that if we have a value in the store, it's the right type
   // (that is, state_optopt_val's inner Option::T is not None)
   let cond_1 = {{
      if has then
        // Since we have a value, state_optopt_val is a Some so unwrap is ok.
         // After unwrapping, the inner value (state_opt_val) should be Some
         // indicating that we did actually get a VecObject.
         Option::is_some (Option::unsafe_unwrap state_optopt_val)
      else True
   }};
   mir_assert {{ cond_1 }};

   // It is now safe to unwrap both Option::T to get the value. If we
   // didn't have a value, use a placeholder. Don't allocate a new
   // VecObject to hold the default value, as in the contract code the
   // custom type value doesn't get converted into a VecObject (and
   // thus allocated) until something happens that converts it to an
   // SDK value.
   //

   // For the placeholder, use Values::VecObject::invalid so it's the
   // right type. This value ought not to exist, really. Note that the
   // reason we need it and the reason all this stuff is structured in
   // this somewhat strange way is that SAW doesn't let us use
   // Cryptol's sum types (and therefore a real Option or Result type)
   // and the rather janky Option type we have as a substitute both
   // (a) has the same problem of needing invalid values and (b) is
   // much harder/more confusing to work with.
   let state_val = {{
      if has then
         Option::unsafe_unwrap (Option::unsafe_unwrap state_optopt_val)
      else
         Values::vecobj_invalid
   }};

   // Now assert that the VecObject we got (if we got one) points to
   // a vector in the host heap.
   let cond_2 = {{
      if has then
         Values::vecobj_valid_with_heap state_val heap
      else True
   }};
   mir_assert {{ cond_2 }};

   // Assert that the value (if we got one) has the right VecObject
   // representation: two entries, both Values::U32::T.
   let cond_3 = {{
      if has then Custom::valid_with_heap state_val heap
      else True
   }};
   mir_assert {{ cond_3 }};

   // Now assert that the passed-in fresh state value is equal to
   // either the decoded VecObject or the default value.
   //
   // Note that if there are host-stored objects in the type one in
   // general needs to use Value::VecObject::eq instead so that the
   // host references are followed.
   let cond_4 = {{
      if has then
         state_native == Custom::val_to_native state_val heap
      else
         state_native == Custom::default_value
   }};
   mir_assert {{ cond_4 }};
};

// Declare specification for get_state function
let get_state_spec = do {
  // Declare a fresh symbolic host heap
  heap <- mir_fresh_cryptol_var "hostheap" {| Values::HostHeap |};

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // get a fresh state value
  state <- custom_fresh_native "get_state::state";

  // assert it is either in the store or the default starting value
  assert_storage_precond heap store state;

  // Attach the SDK state
  soroban_hostheap_assert_state heap;
  soroban_storage_assert_state store;

  // Execute the function with an instance of Env
  mir_execute_func [soroban.smi.EnvVal ()];

  // The SDK state doesn't change
  soroban_hostheap_assert_state heap;
  soroban_storage_assert_state store;

  // get Rust u32 values
  let count_mir = mir_term {{ state.0 }};
  let last_mir = mir_term {{ state.1 }};

  // cons up the return value, which is a struct of the custom type
  let ty = mir_find_adt mod "soroban_custom_types_contract::State" [];
  let ret = mir_struct_value ty [count_mir, last_mir];
  
  // return it
  mir_return ret;
};

// Declare specification for increment function
let increment_spec = do {
  // Declare a fresh symbolic host heap
  heap <- mir_fresh_cryptol_var "hostheap" {| Values::HostHeap |};

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // get a fresh state value
  state <- custom_fresh_native "get_state::state";

  // assert it is either in the store or the default starting value
  assert_storage_precond heap store state;

  // get an argument
  incr_native <- mir_fresh_cryptol_var "incr" {| [32] |};

  // Attach the SDK state
  soroban_hostheap_assert_state heap;
  soroban_storage_assert_state store;

  // Execute the function with an instance of Env and the argument
  // (which is a Rust u32)
  mir_execute_func [soroban.smi.EnvVal (), mir_term incr_native];

  // Compute updated count
  let count_native' = {{ state.0 + incr_native }};
  let last_native' = incr_native;

  // Convert to Values::U32::T
  let count_val' = {{ Values::u32_of_native count_native' }};
  let last_val' = {{ Values::u32_of_native last_native' }};

  // allocate a new VecObject
  let state_val'heap' = soroban_value_vecobj_2 count_val' last_val' heap;
  let state_val' = {{ stateval'heap'.0 }};
  let heap' = {{ stateval'heap'.1 }};

  // update the store
  let store' = soroban_store_set store COUNTER state_val';

  // Assert the new SDK state
  soroban_hostheap_assert_state heap';
  soroban_storage_assert_state store';

  // Return the new count as a Rust u32
  mir_return (mir_term count_native');
};

// Run the verification
get_state_override <- soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_custom_types_contract::{impl#10}::get_state",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = get_state_spec,
  // Prover
  proof = w4
};
soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_custom_types_contract::{impl#10}::increment",
  // Additional overrides
  overrides = [get_state_override],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec,
  // Prover
  proof = w4
};
