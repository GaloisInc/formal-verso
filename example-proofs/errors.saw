enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/errors/target/linked-mir.json";

// Initialize soroban verification with storage and symbol APIs
soroban <- soroban_init mod ["storage", "symbol", "u32_val"];

// Compute Symbol value for COUNTER
let COUNTER = {{ Values::symbol_from_native "COUNTER" }};

// The maximum value
let MAX = {{ 5 : [32] }};

// Extract the contract's Error type
let ErrorType = mir_find_adt mod "soroban_errors_contract::Error" [];

// Extract the result type used by the contract function
let ResultType = mir_find_adt mod "core::result::Result" [mir_u32, mir_adt ErrorType];

// Declare first specification for increment function
// This one is for when the counter is not present.
let increment_spec_1 = do {

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // There is no counter value set.
  let has = soroban_store_has store COUNTER;
  mir_precond {{ has == False }};

  // Set store as the initial storage state
  soroban_storage_update_state store;

  // Execute the function with an instance of Env
  mir_execute_func [soroban.smi.EnvVal ()];

  // Compute updated count; with no counter value we start at 0
  let counter_native' = {{ 1 : [32] }};
  let counter_val' = {{ Values::u32_from_native counter_native' }};

  // The final storage state should be the initial store updated to
  // counter_val' at COUNTER.
  soroban_storage_update_state (soroban_store_set store COUNTER counter_val');

  // The code returns the new value; it does so as a Rust u32 (not U32Val) so
  // convert counter_native' to MIR and wrap it in Ok.
  mir_return (mir_enum_value ResultType
              "Ok"
              [mir_term counter_native']);
};

// Declare second specification for increment function
// This one is for when the counter is below the max.
let increment_spec_2 = do {

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // Get value in the store at COUNTER as a Values::U32::T
  // outer None means there was no value
  // inner None means the value wasn't a U32
  let counter_optopt_val = soroban_store_get store COUNTER {| Values::U32T |};

  // The counter value is set
  mir_precond {{ Option::is_some counter_optopt_val }};
  let counter_opt_val = {{ Option::unsafe_unwrap counter_optopt_val }};

  // The conversion to U32 succeeded
  mir_precond {{ Option::is_some counter_opt_val }};
  let counter_val = {{ Option::unsafe_unwrap counter_opt_val }};

  // Get a native bitvector version of the U32
  let counter_native = {{ Values::u32_to_native counter_val }};

  // The counter must be less than MAX
  mir_precond {{ counter_native < MAX }};

  // Set store as the initial storage state
  soroban_storage_assert_state store;

  // Execute the function with an instance of Env
  mir_execute_func [soroban.smi.EnvVal ()];

  // Compute updated count
  let counter_native' = {{ counter_native + 1 }};
  let counter_val' = {{ Values::u32_from_native counter_native' }};

  // Match the intended logic exactly, in case of off-by-one mistakes above
  mir_postcond {{ counter_native <= MAX }};

  // The final storage state should be the initial store updated to
  // counter_val' at COUNTER.
  soroban_storage_assert_state (soroban_store_set store COUNTER counter_val');

  // The code returns the new value; it does so as a Rust u32 (not U32Val) so
  // convert counter_native' to MIR and wrap it in Ok.
  mir_return (mir_enum_value ResultType
              "Ok"
              [mir_term counter_native']);
};

// Declare third specification for increment function
// This one is for when the counter is at or above the max.
let increment_spec_3 = do {

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // Get value in the store at COUNTER as a Values::U32::T
  // outer None means there was no value
  // inner None means the value wasn't a U32
  let counter_optopt_val = soroban_store_get store COUNTER {| Values::U32T |};

  // The counter value is set
  mir_precond {{ Option::is_some counter_optopt_val }};
  let counter_opt_val = {{ Option::unsafe_unwrap counter_optopt_val }};

  // The conversion to U32 succeeded
  mir_precond {{ Option::is_some counter_opt_val }};
  let counter_val = {{ Option::unsafe_unwrap counter_opt_val }};

  // Get a native bitvector version of the U32
  let counter_native = {{ Values::u32_to_native counter_val }};

  // The counter is greater than or equal to MAX
  mir_precond {{ counter_native >= MAX }};

  // Set store as the initial storage state
  soroban_storage_assert_state store;

  // Execute the function with an instance of Env
  mir_execute_func [soroban.smi.EnvVal ()];

  // The storage state is unchanged
  soroban_storage_assert_state store;

  // The code returns error.
  let errcode = mir_enum_value ErrorType "LimitReached" [];
  mir_return (mir_enum_value ResultType "Err" [errcode]);
};

// Run the verification for each spec
// XXX: it seems saw is missing a record update syntax...
let args1 = {
  // Name of function in MIR
  fun = "soroban_errors_contract::{impl#17}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec_1,
  // Prover
  proof = w4
};
let args2 = {
  // Name of function in MIR
  fun = "soroban_errors_contract::{impl#17}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec_2,
  // Prover
  proof = w4
};
let args3 = {
  // Name of function in MIR
  fun = "soroban_errors_contract::{impl#17}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec_2,
  // Prover
  proof = w4
};

soroban_verify soroban args1;
soroban_verify soroban args2;
soroban_verify soroban args3;
