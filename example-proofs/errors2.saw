enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/errors/target/linked-mir.json";

// Initialize soroban verification with storage and symbol APIs
soroban <- soroban_init mod ["storage", "symbol", "u32_val", "core"];

// Compute Symbol value for COUNTER
let COUNTER = {{ Values::symbol_from_native "COUNTER" }};

// The maximum value
let MAX = {{ 5 : [32] }};

// Extract the contract's Error type
let ErrorType = mir_find_adt mod "soroban_errors_contract::Error" [];

// Extract the result type used by the contract function
let ResultType = mir_find_adt mod "core::result::Result" [mir_u32, mir_adt ErrorType];

// Specification for increment function
let increment_spec = do {

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // Check if a counter value is set.
  let has = soroban_store_has store COUNTER;

  counter_val <- sym_if has then do {
     // Get value in the store at COUNTER as a Values::U32::T
     // outer None means there was no value
     // inner None means the value wasn't a U32
     let counter_optopt_val = soroban_store_get store COUNTER {| Values::U32T |};

     // The counter value is set
     mir_precond {{ Option::is_some counter_optopt_val }};
     let counter_opt_val = {{ Option::unsafe_unwrap counter_optopt_val }};

     // The conversion to U32 succeeded
     mir_precond {{ Option::is_some counter_opt_val }};
     let counter_val = {{ Option::unsafe_unwrap counter_opt_val }};

     return counter_val;
  }
  else do {
     // With no counter value we start at 0
     let counter_val = {{ Values::u32_from_native 0 }};
     return counter_val;
  };

  // Get a native bitvector version of the U32
  let counter_native = {{ Values::u32_to_native counter_val }};

  // Set store as the initial storage state
  soroban_storage_assert_state store;

  // Execute the function with an instance of Env
  mir_execute_func [soroban.smi.EnvVal ()];

  // Compute updated count
  let counter_native' = {{ counter_native + 1 }};
  let counter_val' = {{ Values::u32_from_native counter_native' }};

  let succeeds = {{ counter_native' <= MAX }};
  sym_if succeeds then do {
     // The final storage state should be the initial store updated to
     // counter_val' at COUNTER.
     soroban_storage_assert_state (soroban_store_set store COUNTER counter_val');

     // The code returns the new value; it does so as a Rust u32 (not U32Val) so
     // convert counter_native' to MIR and wrap it in Ok.
     mir_return (mir_enum_value ResultType
                 "Ok"
                 [mir_term counter_native']);
  }
  else do {
     // The storage state is unchanged
     soroban_storage_assert_state store;

     // The code returns error.
     let errcode = mir_enum_value ErrorType "LimitReached" [];
     mir_return (mir_enum_value ResultType "Err" [errcode]);
  };
};

// Run the verification.
soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_errors_contract::{impl#17}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec,
  // Prover
  proof = w4
};
