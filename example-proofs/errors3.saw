enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/errors/target/linked-mir.json";

// Initialize soroban verification with storage and symbol APIs
soroban <- soroban_init mod ["storage", "symbol", "u32_val", "core"];

// Compute Symbol value for COUNTER
let COUNTER = {{ Values::symbol_from_native "COUNTER" }};

// The maximum value
let MAX = {{ 5 : [32] }};

// Extract the contract's Error type
let ErrorType = mir_find_adt mod "soroban_errors_contract::Error" [];

// Extract the result type used by the contract function
let ResultType = mir_find_adt mod "core::result::Result" [mir_u32, mir_adt ErrorType];

// Specification for increment function
let increment_spec = do {

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // Check if a counter value is set.
  let has = soroban_store_has store COUNTER;

  // Get value in the store at COUNTER as a Values::U32::T
  // outer None means there was no value
  // inner None means the value wasn't a U32
  let counter_optopt_val = soroban_store_get store COUNTER {| Values::U32T |};

  // establish a precondition where the counter is either not present or contains a U32
  let counter_precond = {{
     if has then
        // since we have a value, counter_optopt_val is a Some so unwrap is ok
        // after unwrapping, the inner value (counter_opt_val), should be Some
        // indicating that we did actually get a U32
        Option::is_some (Option::unsafe_unwrap counter_optopt_val)
     else True
  }};
  mir_precond {{ counter_precond }};

  // now extract the counter value
  let counter_val = {{
     if has then
        // Since we asserted that we got a U32 the inner value is Some
        // so it's ok to unwrap. (Unfortunately we seem to have to
        // re-unwrap the outer value to get the inner value.)
        Option::unsafe_unwrap (Option::unsafe_unwrap counter_optopt_val)
     else
        Values::u32_from_native 0
  }};

  // Get a native bitvector version of the U32
  let counter_native = {{ Values::u32_to_native counter_val }};

  // There's an implicit invariant on the counter state, which is that
  // it is less than or equal to MAX. Make that invariant explicit.
  // FUTURE: we ought to have a more principled way of handling
  // invariants, especially across multiple functions accessing the
  // same state, so they get automatically checked instead of having
  // to be pasted all over the place.
  mir_assert {{ counter_native <= MAX }};

  // Set store as the initial storage state
  soroban_storage_assert_state store;

  // Execute the function with an instance of Env
  mir_execute_func [soroban.smi.EnvVal ()];

  // Check if we can increment. Note that while we'd like to increment
  // first and then check with <= as that matches the specification
  // more closely. (Adjusting this creates a risk of doing it wrong
  // and creating an off-by-one error.) However, we need a bound
  // before incrementing or the counter might overflow.
  let succeeds = {{ counter_native < MAX }};

  // Compute the updated count. Keep the old value if we didn't succeed.
  let counter_native' = {{ if succeeds then counter_native + 1 else counter_native }};
  let counter_val' = {{ Values::u32_from_native counter_native' }};

  // Compute the updated store. This writes the old value back to the
  // store if we're failing, but that's ok.
  let store' = soroban_store_set store COUNTER counter_val';

  // Update the storage state.
  soroban_storage_assert_state store';

  // Assert that we've maintained the invariant.
  mir_assert {{ counter_native' <= MAX }};

  // On success the code returns the new value. It does so as a Rust
  // u32 (not U32Val) so convert counter_native' to MIR and wrap it in
  // Ok.
  let successval = mir_enum_value ResultType "Ok" [mir_term counter_native'];
  // On error the code returns the LimitReached error.
  let errcode = mir_enum_value ErrorType "LimitReached" [];
  let errorval = mir_enum_value ResultType "Err" [errcode];

  // Pick the return based on whether we succeed.
  let retval = mir_mux_values succeeds successval errorval;
  mir_return retval;
};

// Run the verification.
soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_errors_contract::{impl#17}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec,
  // Prover
  proof = w4
};
