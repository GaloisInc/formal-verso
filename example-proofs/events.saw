enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/events/target/linked-mir.json";

// Initialize soroban verification with storage, symbol, and events APIs
soroban <- soroban_init mod ["storage", "symbol", "events", "vec_val", "vec_new_from_slice", "u32_val", "core"];

// Compute Symbol values for COUNTER and increment
let COUNTER = {{ Values::symbol_from_native "COUNTER" }};
let increment = {{ Values::symbol_from_native "increment" }};

// Declare specification for increment function
let increment_spec = do {

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // Check if a counter value is set.
  let has = soroban_store_has store COUNTER;

  // Get value in the store at COUNTER as an Option::T (Option::T (Values::U32::T))
  // outer None means there was no value
  // inner None means the value wasn't a U32
  let counter_optopt_val = soroban_store_get store COUNTER {| Values::U32T |};

  // establish a precondition where the counter is either not present or contains a U32
  let counter_precond = {{
     if has then
        // since we have a value, counter_optopt_val is a Some so unwrap is ok
        // after unwrapping, the inner value (counter_opt_val), should be Some
        // indicating that we did actually get a U32
        Option::is_some (Option::unsafe_unwrap counter_optopt_val)
     else True
  }};
  mir_precond {{ counter_precond }};

  // now extract the counter value
  let counter_val = {{
     if has then
        // Since we asserted that we got a U32 the inner value is Some
        // so it's ok to unwrap. (Unfortunately we seem to have to
        // re-unwrap the outer value to get the inner value.)
        Option::unsafe_unwrap (Option::unsafe_unwrap counter_optopt_val)
     else
        Values::u32_from_native 0
  }};

  // Get a native bitvector version of the U32
  let counter_native = {{ Values::u32_to_native counter_val }};

  // If the count is 0xffffffff, the contract will crash with an
  // integer overflow. Rule that case out as not interesting.
  // (Changing the contract to fail explicitly or whatever else would
  // detract from its value as an example.)
  mir_precond {{ counter_native < 0xffffffff }};

  // Now, get a fresh events state as well.
  events <- mir_fresh_cryptol_var "events" {| EventLog::T |};

  // And get a fresh host heap.
  heap <- mir_fresh_cryptol_var "hostheap" {| Values::HostHeap |};

  // The heap needs to be able to allocate at least once.
  mir_assert {{ Values::heap_has_space heap 1 }};

  // Set the initial state:
  //    heap is the initial hostheap state
  //    store is the initial storage state
  //    events is the initial events state
  soroban_hostheap_assert_state heap;
  soroban_storage_assert_state store;
  soroban_events_assert_state events;

  // Execute the function with an instance of Env
  mir_execute_func [soroban.smi.EnvVal ()];

  // Compute updated count
  let counter_native' = {{ counter_native + 1 }};
  let counter_val' = {{ Values::u32_from_native counter_native' }};

  // Cons up the topic for the event we expect to be issued,
  // which is a pair of the symbols "COUNTER" and "increment".
  heap'topic <- soroban_events_mktopic_2 COUNTER increment heap;
  // Unpack the pair to get the new host heap and the topic value.
  let heap' = {{ heap'topic.0 }};
  let topic = {{ heap'topic.1 }};

  // The final storage state should be the initial store updated to
  // the new counter value at COUNTER. Use the soroban-value version
  // of the counter.
  let store' = soroban_store_set store COUNTER counter_val';

  // The final events state should be the initial state with the
  // generated event appended. The generated event includes the
  // updated counter value.
  events' <- soroban_events_publish events topic counter_val';

  // Assert the final state:
  //    the hostheap state should be the result of the allocation;
  //    the storage state should be the the updated store;
  //    the events state should be the post-publish version.
  soroban_hostheap_assert_state heap';
  soroban_storage_assert_state store';
  soroban_events_assert_state events';

  // The function returns the updated value.
  // The return value is a u32, not a U32Val, so use counter_native'
  // rather than soroban_value_to_mir (counter_val').
  mir_return (mir_term counter_native');
};

// Run the verification
soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_events_contract::{impl#1}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec,
  // Prover
  proof = w4
};
