enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/increment/target/wasm32-unknown-unknown/release/deps/soroban_increment_contract-516a4d3c39f27127.linked-mir.json";

// Initialize soroban verification with storage and symbol APIs
soroban <- soroban_init mod ["storage", "symbol"];

// Bind Cryptol modules so that they are accessible in {{ ... }}
let Storage = soroban.cry.Storage;
let Symbol = soroban.cry.Symbol;

// Compute Symbol value for COUNTER
let COUNTER = {{ Symbol::short "COUNTER" }};

// Declare specification for increment function
let increment_spec = soroban.spec "increment" (\(s : SorobanSpecAPI) -> do {

  // Declare a fresh symbolic Storage
  storage <- s.fresh "storage" {| Storage::T |};

  // Get value in storage at COUNTER as a [32]
  let counter_val = s.storage.get storage COUNTER {| [32] |};
  // Assume that the conversion to [32] is successful, or that there was no
  // value set
  count <- option.unwrap {{ Option::unwrap_or counter_val (Option::ok 0) }};
  // Assume count < 1000 so that we don't get overflow
  mir_precond {{ count < 1000 }};

  // Set storage as the initial storage state
  s.storage.state storage;

  // Execute the function with an instance of Env
  mir_execute_func [s.mir_value.Env ()];

  // Compute updated count
  let count' = {{ count + 1 }};

  // Check that final storage state is initial storage updated to count' at
  // COUNTER
  s.storage.state (s.storage.set storage COUNTER count');

  // Check that count' is returned
  mir_return (s.to_mir_value count');

});

// Run the verification
soroban.verify {
  // Name of function in MIR
  fun = "soroban_increment_contract::{impl#1}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec,
  // Prover
  proof = w4
};
