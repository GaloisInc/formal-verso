enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/increment/target/linked-mir.json";

// Initialize soroban verification with storage and symbol APIs
soroban <- soroban_init mod ["storage", "symbol", "u32_val"];

// Bind Cryptol modules so that they are accessible in {{ ... }}
let Values = soroban.cry.Values;
let Store = soroban.cry.Store;

// Compute Symbol value for COUNTER
let COUNTER = {{ Values::symbol_from_native "COUNTER" }};

// Declare specification for increment function
let increment_spec = soroban.spec "increment" (\(s : SorobanSpecAPI) -> do {

  // Declare a fresh symbolic Store
  store <- s.fresh "store" {| Store::T |};

  // Get value in the store at COUNTER as a Values::U32::T
  let counter_val = s.storage.get store COUNTER {| Values::U32T |};
  // Assume that the conversion is successful, or that there was no
  // value set
  count <- option.unwrap {{ Option::unwrap_or counter_val (Option::ok Values::u32_zero) }};
  // get the [u32] inside the soroban value
  let ncount = {{ Values::u32_to_native count }};
  // Assume count < 1000 so that we don't get overflow
  mir_precond {{ ncount < 1000 }};

  // Set store as the initial storage state
  s.storage.state store;

  // Execute the function with an instance of Env
  mir_execute_func [s.mir_value.Env ()];

  // Compute updated count
  let ncount' = {{ ncount + 1 }};
  let count' = {{ Values::u32_from_native ncount' }};

  // Check that final storage state is initial store updated to count' at
  // COUNTER
  s.storage.state (s.storage.set store COUNTER count');

  // Check that count' is returned
  mir_return (mir_term ncount');

});

// Run the verification
soroban.verify {
  // Name of function in MIR
  fun = "soroban_increment_contract::{impl#1}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec,
  // Prover
  proof = w4
};
