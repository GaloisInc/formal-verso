enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/increment/target/linked-mir.json";

// Initialize soroban verification with storage and symbol APIs
soroban <- soroban_init mod ["storage", "symbol", "u32_val"];

// Compute Symbol value for COUNTER
let COUNTER = {{ Values::symbol_from_native "COUNTER" }};

// Declare specification for increment function
let increment_spec = do {

  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // Get value in the store at COUNTER as a Values::U32::T
  let counter_val = soroban_store_get store COUNTER {| Values::U32T |};
  // Assume that the conversion is successful, or that there was no
  // value set
  count <- option.unwrap {{ Option::unwrap_or counter_val (Option::ok Values::u32_zero) }};
  // get the [u32] inside the soroban value
  let ncount = {{ Values::u32_to_native count }};
  // Assume count < 1000 so that we don't get overflow
  mir_precond {{ ncount < 1000 }};

  // Set store as the initial storage state
  soroban_storage_update_state store;

  // Execute the function with an instance of Env
  mir_execute_func [soroban.smi.EnvVal ()];

  // Compute updated count
  let ncount' = {{ ncount + 1 }};
  let count' = {{ Values::u32_from_native ncount' }};

  // Check that final storage state is initial store updated to count' at
  // COUNTER
  soroban_storage_update_state (soroban_store_set store COUNTER count');

  // Check that count' is returned
  mir_return (mir_term ncount');

};

// Run the verification
soroban.verify {
  // Name of function in MIR
  fun = "soroban_increment_contract::{impl#1}::increment",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = increment_spec,
  // Prover
  proof = w4
};
