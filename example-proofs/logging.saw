enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../soroban-examples/logging/target/linked-mir.json";

// Initialize soroban verification with logging API and symbols,
// plus string and vector values
soroban <- soroban_init mod ["logging", "symbol", "str_val", "string_new_from_slice", "vec_val", "vec_new", "vec_push_back", "u32_val", "core"];

// Specification for hello function
let hello_spec = do {
  // Get a fresh symbol to use as the argument
  sym <- soroban_value_fresh "sym" {| Values::SymbolT |};

  // Construct the MIR version of the symbol
  let mir_sym = soroban_value_to_mir soroban.smi sym;

  // Get a fresh symbolic heap
  heap <- mir_fresh_cryptol_var "heap" {| Values::HostHeap |};
  mir_assert {{ Values::heap_has_space heap 3 }};

  // Declare a fresh symbolic log
  log <- mir_fresh_cryptol_var "log" {| Log::T |};

  // Assert the initial SDK state
  soroban_hostheap_assert_state heap;
  soroban_logging_assert_state log;

  // Execute the function with an instance of Env and the symbol
  mir_execute_func [soroban.smi.EnvVal (), mir_sym];

  // Update the log. For now we're just counting the messages.
  let log' = {{ Log::add log }};

  // Update the logging state.
  soroban_logging_assert_state log';

  // Function returns Rust void.
};

// Run the verification.
soroban_verify soroban {
  // Name of function in MIR
  fun = "soroban_logging_contract::{impl#1}::hello",
  // Additional overrides
  overrides = [],
  // Path satisfiability
  path_sat = true,
  // Specification
  spec = hello_spec,
  // Prover
  proof = w4
};
