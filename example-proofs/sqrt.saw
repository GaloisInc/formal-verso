enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../extra-examples/sqrt/target/wasm32-unknown-unknown/release/deps/sqrt_contract-e07ee5799034f7fe.linked-mir.json";

// Initialize soroban verification with storage API
soroban <- soroban_init mod ["storage"];

// Bind Cryptol modules so that they are accessible in {{ ... }}
let Storage = soroban.cry.Storage;

// Declare specification for log2 function
let log2_spec = soroban.spec "log2" (\(s : SorobanSpecAPI) -> do {
  // Declare a fresh symbolic [32]
  x <- s.fresh "x" {| [32] |};
  // Execute the function with x as argument
  mir_execute_func [s.to_mir_value x];
  // Check that the return value is correct
  mir_return (s.to_mir_value {{
    // We can express this in terms of Cryptol's built in lg2 function, but
    // Cryptol's lg2 rounds up and ours rounds down
    if 2 ^^ y == x \/ x == 0 then y else y - 1
    where y = lg2 x
  }});
});

// Verify log2, and obtain an override for it
log2_ov <- soroban.verify {
  fun = "sqrt_contract::{impl#1}::log2",
  overrides = [],
  path_sat = true,
  spec = log2_spec,
  proof = w4
};

// Declare the specification of sqrt, expressed as a relation
let {{
  // y = sqrt(x)
  isSqrt : [32] -> [32] -> Bit
  isSqrt x y =
    y < 2^^16 /\ y^^2 <= x /\ (y == 2^^16 - 1 \/ (y + 1)^^2 > x)
}};

// Prove that the relation is right-unique
// Warning: will take a while! Run with solver caching on
prove_print w4 {{ \x y1 y2 -> isSqrt x y1 /\ isSqrt x y2 ==> y1 == y2 }};

// Declare specification for sqrt function
let sqrt_spec = soroban.spec "sqrt" (\(s : SorobanSpecAPI) -> do {
  x <- s.fresh "x" {| [32] |};
  mir_execute_func [s.to_mir_value x];
  // Check that the function returns a (the) value which satisfies isSqrt x
  y <- s.fresh "y" {| [32] |};
  mir_postcond {{ isSqrt x y }};
  mir_return (s.to_mir_value y);
});

// Verify sqrt, using the log2 override
// Warning: will take a while! Run with solver caching on
sqrt_ov <- soroban.verify {
  fun = "sqrt_contract::{impl#1}::sqrt",
  overrides = [log2_ov],
  path_sat = true,
  spec = sqrt_spec,
  proof = w4
};

// Declare specification for sqrt_cached function
let sqrt_cached_spec = soroban.spec "sqrt_cached" (\(s : SorobanSpecAPI) -> do {
  // Declare a fresh symbolic Storage
  storage <- s.fresh "storage" {| Storage::T |};
  x <- s.fresh "x" {| [32] |};
  // Get value in storage at x as a [32]
  let cached = s.storage.get storage x {| [32] |};
  // Assume that either there is no value, or there is one and it can be
  // converted to [32] and it satisfies isSqrt x
  mir_precond {{ Option::ok_implies (Option::ok_and (isSqrt x)) cached }};
  // Set storage as the initial storage state
  s.storage.state storage;
  // Execute the function with an instance of Env and x
  mir_execute_func [s.mir_value.Env (), s.to_mir_value x];
  // Declare y and constrain it to satisfy isSqrt x
  y <- s.fresh "y" {| [32] |};
  mir_postcond {{ isSqrt x y }};
  // Check that the final storage state is initial storage updated to y at x
  s.storage.state (s.storage.set storage x y);
  // Check that y is returned
  mir_return (s.to_mir_value y);
});

// Verify sqrt_cached, using the sqrt override
// Warning: will take a while! Run with solver caching on
soroban.verify {
  fun = "sqrt_contract::{impl#1}::sqrt_cached",
  overrides = [sqrt_ov],
  path_sat = true,
  spec = sqrt_cached_spec,
  proof = w4
};
