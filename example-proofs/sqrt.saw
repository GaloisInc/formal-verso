enable_experimental;

include "../lib/option.saw";
include "../lib/soroban.saw";

// Load linked-mir.json generated by cargo saw-build
mod <- mir_load_module "../extra-examples/sqrt/target/linked-mir.json";

// Initialize soroban verification with storage API
soroban <- soroban_init mod ["u32_val", "storage"];

// Declare specification for log2 function
let log2_spec = do {
  // Declare a fresh symbolic [32]
  x <- mir_fresh_cryptol_var "x" {| [32] |};

  // Execute the function with x as argument
  mir_execute_func [mir_term x];

  // Check that the return value is correct
  let correct = {{
    // We can express this in terms of Cryptol's built in lg2 function, but
    // Cryptol's lg2 rounds up and ours rounds down
    if 2 ^^ y == x \/ x == 0 then y else y - 1
    where y = lg2 x
  }};
  mir_return (mir_term correct);
};

// Verify log2, and obtain an override for it
log2_ov <- soroban_verify soroban {
  fun = "sqrt_contract::{impl#1}::log2",
  overrides = [],
  path_sat = true,
  spec = log2_spec,
  proof = w4
};

// Declare the specification of sqrt, expressed as a relation
//
// In particular, since we're working with integers, we're proving
// y = floor(sqrt(x)), and since we're working with 32-bit machine
// integers, stop at 65535 and avoid overflowing in the spec logic.
let {{
  // y = sqrt(x)
  isSqrt : [32] -> [32] -> Bit
  isSqrt x y =
    y < 2^^16 /\ y^^2 <= x /\ (y == 2^^16 - 1 \/ (y + 1)^^2 > x)
}};

// Prove that the relation is right-unique
// Warning: will take a while! Run with solver caching on
prove_print w4 {{ \x y1 y2 -> isSqrt x y1 /\ isSqrt x y2 ==> y1 == y2 }};

// Declare specification for sqrt function
let sqrt_spec = do {
  x <- mir_fresh_cryptol_var "x" {| [32] |};
  mir_execute_func [mir_term x];
  // Check that the function returns a (the) value which satisfies isSqrt x
  y <- mir_fresh_cryptol_var "y" {| [32] |};
  mir_postcond {{ isSqrt x y }};
  mir_return (mir_term y);
};

// Verify sqrt, using the log2 override
// Warning: will take a while! Run with solver caching on
sqrt_ov <- soroban_verify soroban {
  fun = "sqrt_contract::{impl#1}::sqrt",
  overrides = [log2_ov],
  path_sat = true,
  spec = sqrt_spec,
  proof = w4
};

// Declare specification for sqrt_cached function
let sqrt_cached_spec = do {
  // Declare a fresh symbolic store
  store <- mir_fresh_cryptol_var "store" {| Store::T |};

  // Declare a fresh variable for the argument
  x <- mir_fresh_cryptol_var "x" {| [32] |};
  let xval = {{ Values::u32_from_native x }};

  // Get value in the store at x as an Option::T (Option::T Values::U32::T)
  // outer None means there was no value
  // inner None means the value wasn't a U32
  let optopt_cached_val = soroban_store_get store xval {| Values::U32T |};

  // If there is no value, assert True.
  // If the value wasn't a U32, assert False.
  // If there was a U32 value, assert isSqrt on it after converting to native.
  mir_precond {{ Option::ok_implies (Option::ok_and (\y -> isSqrt x (Values::u32_to_native y))) optopt_cached_val }};

  // Set store as the initial storage state
  soroban_storage_assert_state store;

  // Execute the function with an instance of Env and x
  mir_execute_func [soroban.smi.EnvVal (), mir_term x];

  // Declare y and constrain it to satisfy isSqrt x
  y <- mir_fresh_cryptol_var "y" {| [32] |};
  let yval = {{ Values::u32_from_native y }};
  mir_postcond {{ isSqrt x y }};

  // Check that the final storage state is initial store updated to y at x
  soroban_storage_assert_state (soroban_store_set store xval yval);

  // Check that y is returned
  // note: the Rust code returns u32, not U32Val, so use y (of type [32]
  // which corresponds to u32) not yval (of type Values::U32::T which
  // corresponds to U32Val)
  mir_return (mir_term y);
};

// Verify sqrt_cached, using the sqrt override
// Warning: will take a while! Run with solver caching on
soroban_verify soroban {
  fun = "sqrt_contract::{impl#1}::sqrt_cached",
  overrides = [sqrt_ov],
  path_sat = true,
  spec = sqrt_cached_spec,
  proof = w4
};
