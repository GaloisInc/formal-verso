module Auth where

import Array

import Values as Values
import submodule Values::Raw as Values::Raw
import submodule Values::Void as Values::Void
import submodule Values::Symbol as Values::Symbol
import submodule Values::AddressObject as Values::AddressObject
import submodule Values::VecObject as Values::VecObject

/*
 * Model for the Soroban SDK authorization system.
 *
 * The basis of the authorization system is a concept of call-graph
 * fragments.
 *
 * As I understand it (note that my understanding is based on a lot of
 * guesswork because the documentation is not very clear, and may be
 * quite wrong so far) this probably works as follows:
 *
 * 1. Each call-graph fragment is associated with a particular
 * Address, and represents a projection of a contract execution call
 * graph where (a) all functions in a given contract are folded
 * together, and (b) contracts that don't make authorization calls
 * about the Address in question are dropped. Chains or subgraphs of
 * dropped nodes are replaced with a single edge. Nodes dropped at the
 * root of the graph are dropped completely.
 *
 * Thus, a fragment (a, f -> g -> h) represents a call chain from f to
 * g to h, where f, g, and h each make an authorization check on
 * address a. This allows f to call g and then g to call h, but does
 * not allow f to call h directly, or allow either g or h to be called
 * spontaneously rather than starting from f. However, other contracts
 * that don't check for authorization from a can be interspersed
 * freely.
 *
 * These fragments are described as trees rather than graphs; it
 * appears that each end corresponds to a single invocation, not a
 * general ability to invoke. So for a situation where f calls g
 * twice, and each call to g calls h, you write a fragment of the
 * form
 *       f --> g -> h
 *         \-> g -> h
 * rather than either the form
 *       f --> g --> h
 *         \-> g -/
 * or just
 *       f -> g -> h
 * but this is not totally clear. It is also not clear if these
 * two fragments are different:
 *       f --> g -> w
 *         \-> g -> z
 * and
 *       f --> g -> z
 *         \-> g -> w
 * that is, whether the sub-nodes are ordered or not.
 *
 * 2. When we start executing we have some collection of call graph
 * fragments that we're allowed to execute; these have been signed
 * by the principal behind the Address associated with the fragment.
 *
 * 3. During execution, when an authorization call happens, we search
 * for a fragment with an unused node matching it that will let us
 * conclude the call is authorized. Then we mark off the node we just
 * matched in the fragment as used. When all the nodes in the fragment
 * have been used, the whole fragment is marked used and/or discarded.
 *
 * 4. It appears that a node in a fragment matches if:
 *    - it names the same contract
 *    - the enclosed arguments list matches (see further notes below)
 *    - and either:
 *         - it is the root of the fragment
 *         - it is the (or a) next unused node in the fragment and its
 *           parent in the fragment is still in the current call chain
 *
 * That is, as you execute you pick fragments that authorize you to
 * execute, and these authorize particular patterns of calls, which
 * then get discharged and marked used one at a time. If/once
 * execution deviates from the pattern the fragment can no longer
 * authorize further calls.
 *
 * As noted above, it's unclear if the patterns of calls are intended
 * to be ordered. Thus, given the example
 *       f --> g -> w
 *         \-> g -> z
 * it's not clear if the sequence
 *    call f, call g, call z, return z, return g, call g, call w, return all
 * is potentially authorized or only the sequence
 *    call f, call g, call w, return z, return g, call g, call w, return all
 * though it is definitely the case that just
 *    call f, call g, call z, return z, return g, return f
 * or
 *    call f, call g, call w, return w, return g, return f
 * are authorized, and
 *    call f, call g, call z, return z, call w
 * is not.
 *
 * It's also unclear if you can have more than one active fragment for
 * the same Address at a time. That is, if you have the two fragments
 *       f -> g -> w
 *       g -> z
 * it's not clear if this sequence is authorized:
 *    call f, call g, call z, return z, return g, call g, call w, return all
 * because it uses the g -> z fragment while the other fragment is
 * partially discharged and then returns to using it. Similarly, it's
 * not clear if the sequence
 *    call f, call g, call z, call g, call w, return z, return w, return all
 * with two live invocations of g at once is supposed to be
 * authorized. From the apparent intent of the system it seems like
 * the first should be authorized but not the second, but it's hard to
 * see how they can readily be distinguished.
 *
 * Finally, if there are multiple possibly matching fragments, it's
 * not clear which you select to match, and contrary to a vague
 * statement in the docs, it does matter. For example, given these
 * two fragments:
 *       f -> g -> w
 *       f -> g -> z
 * which do you pick to start using and mark partially used when a
 * sequence begins with call f? It seems like to satisfy the apparent
 * intent of the system you have to choose both nondeteriminstically
 * and only resolve which one you actually mark used when it becomes
 * unambiguous. (And if you still have multiple potentially used
 * fragments when you're done executing, which do you pick? If they're
 * the same it doesn't matter, and if one's a subgraph of another it's
 * clear you should pick the smaller one, but in general there's no
 * obvious answer.)
 *
 * 5. In addition to the structural matching described above, each
 * node also has a list of values in it, which correspond to the
 * arguments to be passed to the function. These need to be matched at
 * runtime by the arguments given. It isn't clear how these values are
 * supposed to be matched and the documentation is silent, but it
 * appears the intent is just an equality test: the values found at
 * runtime should be the same list as the values found in the fragment.
 *
 * There are two variants of the authorization hypercall, one of which
 * defaults to the argument list from the current invocation, and the
 * other of which takes an explicit argument list. It seems the idea
 * is that the latter can be arbitrary (though related somehow to the
 * current invocation) and the person creating the authorization
 * fragments is supposed to know what'll be posted at runtime so they
 * can include the right list of values in their fragments. This
 * allows e.g. suppressing arguments that are irrelevant to the
 * Address being consulted.
 *
 * Given all the uncertainty above, and given that the more complete
 * model I started out with completely overwhelmed the verification
 * system, I've implemented the following.
 *
 * (Note that because we don't actually support cross-contract calls
 * yet, we can only use this for one contract at a time, so what's
 * here is sufficient for current purposes.)
 *
 * A. You can authorize multiple call-graph fragments, but they'll
 * always be used in the order given.
 *
 * B. Call-graph fragments are restricted to linear chains. That is,
 * you can have f -> g -> h, but not any of the branching cases
 * described above.
 *
 * C. Call-graph nodes track the function involved and the argument
 * list.
 *
 * D. We can only be matching in one place at one time. That means
 * only one fragment at a time. That place can be:
 *    - before any node in the current fragment
 *    - after all the nodes in the current fragment
 *    - after the current fragment
 *
 * In the first case, if the current call matches, we succeed and
 * advance past the current node.
 *
 * In the first case, if the current call doesn't match we assume the
 * fragment's done and move past it to the next fragment.
 *
 * In the second case the fragment is done so we move past it.
 *
 * In the third case we advance to the next fragment. When we run out
 * of fragments, further authorization attempts fail.
 *
 * E. In principle if we are partway through a fragment and the
 * current contract function returns we should skip over any pieces of
 * the current fragment this renders inaccessible. In this version
 * this does nothing because we can't be partway through a fragment.
 * (XXX: However, there should be an external hook for triggering this
 * case. That doesn't exist yet, because it's not clear what it should
 * look like until we have logic for cross-contract calls.)
 *
 * F. The top-level contract spec should assert the following
 * preconditions:
 *    - that the authorization state is valid (with "valid")
 *    - what the current invocation is (with "invocation"), passing
 *      the current contract function name and current function
 *      argument list
 *    - that the match state is the initial state (with "initial")
 *      (in principle one may start with a partially discharged state,
 *      but there isn't currently direct support for asserting it)
 * then it should add authorization fragments with "authorize". (This
 * can be done repeatedly to add additional call-graph fragments. The
 * node list for each should be a list of contract function names and
 * argument lists.) It should then bind the resulting auth object to
 * the contract's pre-state.
 *
 * G. The top-level contract spec should then generate an updated auth
 * model by using one of the authorization functions (corresponding to
 * the authorization call the contract makes) and bind the result to
 * the contract's post-state.
 *
 * H. The saw-script wrapper code in soroban.saw provides wrappers for
 * these operations and ghost-state tracking for the pre-state and
 * post-state, as well as specs for the hypercalls involved.
 *
 * I. Because we don't have contract IDs yet (they are BytesObjects,
 * which we don't have support for) we use the Symbol for the function
 * name as the contract function name. In the long run this should
 * probably be either the contract ID or the contract ID paired with
 * the function name.
 */


////////////////////////////////////////////////////////////
// types

type T = Auth

private
   /*
    * We use the following representation:
    *
    * (1) to represent the authorization fragment:
    *    - the number of fragments
    *    - an array mapping fragment -> the address for that fragment
    *    - an array mapping fragment -> number of nodes in that fragment
    *    - an array mapping fragment ->
    *         an array mapping node -> contract function name
    *    - an array mapping fragment ->
    *         an array mapping node -> number of arguments
    *    - an array mapping fragment ->
    *         an array mapping node -> array mapping ArgNum to Values::Raw::T
    *
    * Because we don't support contract IDs yet, for now use the
    * Symbol for the function name instead.
    *
    * We'll use 8-bit values to count things to try to reduce the
    * state space, and keep things from getting out of hand.
    *
    * (2) to represent the matching state:
    *    - an array mapping address -> current fragment
    *    - an array mapping address -> next node in fragment to match against
    *
    * (3) to represent the currently running invocation:
    *    - the current contract function name (as noted above, a
    *      Symbol for the function name)
    *    - an ArgBundle for the args
    *
    * where an ArgBundle is a pair
    *    (number-of-args, array mapping arg to RawVal)
    *
    * We use these ArgBundles rather than VecObjects to avoid needing
    * to cons up extra VecObjects under the covers, as that would mess
    * up the heap state.
    */

   // types for the array indexes
   type FragNum = [8]
   type NodeNum = [8]
   type ArgNum = [8]

   // internal representation of an arglist (count and values)
   type ArgBundle = (ArgNum, Array ArgNum Values::Raw::T)

   newtype Auth = {
      // Number of fragments (entries 0..n-1 exist in the FragNum arrays)
      numfragments: FragNum,

      // The address and number of nodes for each fragment
      addresses: Array FragNum Addr,
      numnodes: Array FragNum NodeNum,

      // The contract (actually function name) for each node in each fragment
      contracts: Array FragNum (Array NodeNum Values::Symbol::T),

      // The argument list for the each node in each fragment
      nargs: Array FragNum (Array NodeNum ArgNum),
      args: Array FragNum (Array NodeNum (Array ArgNum Values::Raw::T)),

      // The match state: whether the fragment is done, and if
      // not the next node we're going to use within it.
      curfragment: Array Addr FragNum,
      nextnode: Array Addr NodeNum,

      // The current invocation state. This may need to grow later.
      invokedcontract: Values::Symbol::T,
      invokedargs: ArgBundle
   }

   // shorten these so the type signatures are readable
   type Heap = Values::HostHeap
   type Addr = Values::AddressObject::T


////////////////////////////////////////////////////////////
// predicates

private
   /*
    * Check that an ArgBundle is valid.
    */
   argbundle_valid: ArgBundle -> Bool
   argbundle_valid (nargs, args) = checkargs nargs
      where
         checkargs i =
            if i == 0 then True
            else arg_valid i && checkargs (i - 1)
         arg_valid i = Values::raw_valid (arrayLookup args i)

   /*
    * Check that two ArgBundles are exactly the same.
    *
    * This version is used for initializing the pre-state, so require
    * pointer equality of the argument values rather than inspecting
    * the heap.
    */
   argbundle_identical: ArgBundle -> ArgBundle -> Bool
   argbundle_identical (nargs1, args1) (nargs2, args2) =
      (nargs1 == nargs2) && (arrayEq args1 args2)

   /*
    * Check that two ArgBundles contain equal values.
    *
    * This version looks in the heap so that large objects are
    * compared by value rather than identity. Check for exact
    * equality first because if true it'll be a lot faster.
    */
   argbundle_eq: ArgBundle -> ArgBundle -> Heap -> Bool
   argbundle_eq (nargs1, args1) (nargs2, args2) heap =
      (nargs1 == nargs2) && (arrayEq args1 args2 || args_eq)
      where
         args_eq = check nargs1
         check i = Values::Raw::eq arg1 arg2 heap
            where
               arg1 = arrayLookup args1 i
               arg2 = arrayLookup args2 i

   /*
    * Check that a full fragment (as passed to authorize, as a list
    * of nodes) is valid.
    *
    * Not actually used here because it's only needed for defining
    * correctness properties of authorize, and for the time being
    * Cryptol can't check those itself because they involve arrays.
    */
   nodelist_valid: {n} fin n => [n] (Values::Symbol::T, ArgBundle) -> Bool
   nodelist_valid nodes = oks ! 0
      where
         oks = [True] # [checknode node && ok'
                           | ok' <- oks
                           | node <- nodes]
         checknode (contract, args) =
            Values::Symbol::valid contract && argbundle_valid args

/*
 * Check that an Auth is valid. Meant for preconditions.
 */
valid: Auth -> Bool
valid auth = conditions
   where
      conditions =
         fragments_valid &&
         matchstates_valid &&
         invokedcontract_valid &&
         invokedargs_valid
      fragments_valid = checkfrags auth.numfragments
      checkfrags i =
         if i == 0 then True
         else fragment_valid (i - 1) && checkfrags (i - 1)
      fragment_valid frag = addr_valid && (numnodes > 0) && nodes_valid
         where
            addr = arrayLookup auth.addresses frag
            addr_valid = Values::AddressObject::valid addr
            numnodes = arrayLookup auth.numnodes frag
            nodes_valid = checknodes numnodes
            checknodes i =
               if i == 0 then True
               else node_valid (i - 1) && checknodes (i - 1)
            node_valid node = contract_valid && args_valid
               where
                  contracts = arrayLookup auth.contracts frag
                  contract = arrayLookup contracts node
                  contract_valid = Values::Symbol::valid contract
                  nargs = arrayLookup (arrayLookup auth.nargs frag) node
                  args = arrayLookup (arrayLookup auth.args frag) node
                  args_valid = argbundle_valid (nargs, args)
      // Blegh, you can't just write forall addr; we need to know the
      // addresses involved. Annoying, especially since it seems that
      // since the array has to have a finite number of distinct
      // elements you _ought_ to be able to just visit all the values
      // in it. I guess we visit all the addresses in auth.addresses.
      matchstates_valid = checkaddrs auth.numfragments
      checkaddrs i =
         if i == 0 then True
         else matchstate_valid (getaddr (i - 1)) && checkaddrs (i - 1)
      getaddr frag =
         arrayLookup auth.addresses frag
      matchstate_valid addr = curfragment_valid && nextnode_valid
         where
            curfragment = arrayLookup auth.curfragment addr
            run_out = curfragment == auth.numfragments
            in_range = curfragment < auth.numfragments
            points_properly = Values::AddressObject::eq addr addr'
               where addr' = arrayLookup auth.addresses curfragment
            curfragment_valid = run_out || (in_range && points_properly)
            // Note: because fragments aren't allowed to be empty,
            // nextnode == 0 is always valid. However, numnodes is not
            // meaningful if curfragment is auth.numfragments. Don't rely
            // on it not being 0.
            nextnode = arrayLookup auth.nextnode addr
            numnodes = arrayLookup auth.numnodes curfragment
            nextnode_valid = (nextnode == 0) || (nextnode < numnodes)
      invokedcontract_valid =
         Values::Symbol::valid auth.invokedcontract
      invokedargs_valid =
         argbundle_valid auth.invokedargs

/*
 * Check that an Auth is empty, that is, no authorization fragments
 * have been added to it yet.
 *
 * Note that there's a complication: when it's empty, we can't
 * assert that it's in the initial state because we need the
 * addresses in the authorization fragments to inspect the
 * match state. So I think the proper approach, if you want to
 * be explicit about authorization fragments, is as follows:
 *    auth0 <- mir_fresh_cryptol_var {| Auth::T |};
 *    mir_assert {{ Auth::empty auth0 }};
 *    let auth1 = {{ Auth::authorize auth0 ... }};
 *    mir_assert {{ Auth::initial auth1 }};
 * but I'm not sure that'll actually work. We might need to
 * muck about.
 *
 * Also we can't even usefully assert that the match state is
 * valid, so the above may not work at all. Will need to find out,
 * I guess.
 */
isempty: Auth -> Bool
isempty auth = valid auth && (auth.numfragments == 0)

/*
 * Check that an Auth is valid _and_ in an initial state:
 * nothing has been consumed yet. Meant for preconditions.
 *
 * Only affects the match state but requires the authorization
 * data to have been loaded already.
 */
initial: Auth -> Bool
initial auth = valid auth && matchstates_initial
   where
      // compare matchstates_valid
      matchstates_initial = checkaddrs auth.numfragments
      checkaddrs i =
         if i == 0 then True
         else matchstate_initial (getaddr (i - 1)) && checkaddrs (i - 1)
      getaddr frag =
         arrayLookup auth.addresses frag
      matchstate_initial addr = curfragment_ok && (nextnode == 0)
         where
            nextnode = arrayLookup auth.nextnode addr
            // curfragment should be the smallest fragment number that
            // points at the right address; that is, every smaller
            // fragment number should point to some other address.
            curfragment = arrayLookup auth.curfragment addr
            curfragment_ok = (curfragment == 0) || check (curfragment - 1)
            check i =
               if i == 0 then True
               else different_addr (i - 1) && check (i - 1)
            different_addr frag = (same == False)
               where
                  addr' = arrayLookup auth.addresses frag
                  same = Values::AddressObject::eq addr addr'

/*
 * Check the invocation state of an Auth.
 *
 * Use argbundle_identical because this is actually for initializing
 * the pre-state.
 */
invocation: Heap -> Auth -> Values::Symbol::T -> ArgBundle -> Bool
invocation heap auth sym args = sym_eq && args_eq
   where
      sym_eq = Values::Symbol::eq auth.invokedcontract sym heap
      args_eq = argbundle_identical auth.invokedargs args


////////////////////////////////////////////////////////////
// authorize

/*
 * Convert a VecObject to an ArgBundle.
 */
argbundle_of_vecobj: Values::HostHeap -> Values::VecObject::T -> ArgBundle
argbundle_of_vecobj heap vec = (nargs, args)
   where
      (_ # nargs) = Values::VecObject::len vec heap
      get i = Values::VecObject::get vec (zext i) heap
      empty = arrayConstant (Values::Void::to_raw Values::unit)
      insert arr i = arrayUpdate arr i (get i)
      mkargs i = if i == 0 then empty else insert (mkargs (i - 1)) i
      args = mkargs nargs

/*
 * Convert a list to an ArgBundle.
 */
argbundle_of_list: {n} n < 256 => [n] Values::Raw::T -> ArgBundle
argbundle_of_list vals = zz ! 0
   where
      empty = arrayConstant (Values::Void::to_raw Values::unit)
      zz = [(0, empty)] # [(i + 1, arrayUpdate args' i v)
                              | (i, args') <- zz
                              | v <- vals]

private
   /*
    * Convert a list of nodes to an array for use as the fragment.
    *
    * The default value in the array is the first node. We have to be
    * careful to be consistent about that so that SMT-level equality
    * of arrays is consistent with intended-contents-only equality.
    */
   makenodes: {n} (0 < n, n < 256) =>
      [n] (Values::Symbol::T, ArgBundle) -> (NodeNum, Array NodeNum Values::Symbol::T, Array NodeNum ArgNum, Array NodeNum (Array ArgNum Values::Raw::T))
   makenodes nodes = arrays ! 0
      where
         [(firstsym, (firstnargs, firstargs))] # rest = nodes
         arrays =
            [(1, arrayConstant firstsym, arrayConstant firstnargs, arrayConstant firstargs)] #
            [(i + 1, arrayUpdate symarray i sym, arrayUpdate nargarray i nargs, arrayUpdate argarray i args)
                | (i, symarray, nargarray, argarray) <- arrays
                | (sym, (nargs, args)) <- rest]

/*
 * Bind a fragment to an authorization state.
 *
 * Leaves the matching state and invocation state alone, so you can
 * assert about that separately.
 */
authorize: {n} (0 < n, n < 256) =>
   Auth -> Addr -> [n] (Values::Symbol::T, ArgBundle) -> Auth
authorize auth addr nodes = auth'
   where
      frag = auth.numfragments
      numfragments' = frag + 1
      addresses' = arrayUpdate auth.addresses frag addr
      (num, contracts, nargs, args) = makenodes nodes
      numnodes' = arrayUpdate auth.numnodes frag num
      contracts' = arrayUpdate auth.contracts frag contracts
      nargs' = arrayUpdate auth.nargs frag nargs
      args' = arrayUpdate auth.args frag args
      auth' = Auth {
         numfragments = numfragments',

         addresses = addresses',
         numnodes = numnodes',
         contracts = contracts',
         nargs = nargs',
         args = args',

         curfragment = auth.curfragment,
         nextnode = auth.nextnode,

         invokedcontract = auth.invokedcontract,
         invokedargs = auth.invokedargs
      }


////////////////////////////////////////////////////////////
// check

private
   /*
    * Update this Address's current node.
    */
   set_nextnode: Auth -> Addr -> NodeNum -> Auth
   set_nextnode auth addr node = auth'
      where
         auth' = Auth {
            numfragments = auth.numfragments,

            addresses = auth.addresses,
            numnodes = auth.numnodes,
            contracts = auth.contracts,
            nargs = auth.nargs,
            args = auth.args,

            curfragment = auth.curfragment,
            nextnode = arrayUpdate auth.nextnode addr node,

            invokedcontract = auth.invokedcontract,
            invokedargs = auth.invokedargs
         }

   /*
    * Update this Address's current fragment.
    */
   set_curfragment: Auth -> Addr -> FragNum -> Auth
   set_curfragment auth addr frag = auth'
      where
         auth' = Auth {
            numfragments = auth.numfragments,

            addresses = auth.addresses,
            numnodes = auth.numnodes,
            contracts = auth.contracts,
            nargs = auth.nargs,
            args = auth.args,

            curfragment = arrayUpdate auth.curfragment addr frag,
            nextnode = auth.nextnode,

            invokedcontract = auth.invokedcontract,
            invokedargs = auth.invokedargs
         }

   /*
    * We are done with the current fragment. Mark it done, and move to
    * the next fragment for the current Address. Set nextnode to 0 so
    * we're at its beginning.
    */
   finish_fragment: Auth -> Addr -> Auth
   finish_fragment auth addr =
      if sameaddr || ran_out then auth''
      else finish_fragment auth'' addr
      where
         frag = arrayLookup auth.curfragment addr
         frag' = frag + 1
         auth' = set_curfragment auth addr frag'
         auth'' = set_nextnode auth' addr 0
         addr' = arrayLookup auth''.addresses frag'
         sameaddr = Values::AddressObject::eq addr addr'
         ran_out = frag' >= auth'.numfragments

   /*
    * Move to the next node in the current fragment. If we run out,
    * advance to the next fragment.
    */
   advance_to_next_node: Auth -> Addr -> Auth
   advance_to_next_node auth addr =
      if done then finish_fragment auth addr
      else set_nextnode auth addr nextnode'
      where
         frag = arrayLookup auth.curfragment addr
         numnodes = arrayLookup auth.numnodes frag
         nextnode = arrayLookup auth.nextnode addr
         nextnode' = nextnode + 1
         done = nextnode' >= numnodes

   /*
    * Check if the given node of the given fragment matches the
    * contract function and argument list presented for authorization
    * (the contract function in question is always the current invoked
    * one)
    */
   match_node: Heap -> Auth -> FragNum -> NodeNum -> ArgBundle -> Bool
   match_node heap auth frag node argsfound = contract_ok && args_ok
      where
         contract = arrayLookup (arrayLookup auth.contracts frag) node
         nargs = arrayLookup (arrayLookup auth.nargs frag) node
         args = arrayLookup (arrayLookup auth.args frag) node
         contract_ok = Values::Symbol::eq contract auth.invokedcontract heap
         args_ok = argbundle_eq (nargs, args) argsfound heap

   /*
    * Match against the given Address's current fragment. If it has
    * run out, or if match_node says the next node doesn't match,
    * return false.
    */
   match_fragment: Heap -> Auth -> Addr -> ArgBundle -> Bool
   match_fragment heap auth addr args = (nextnode < numnodes) && matches
      where
         frag = arrayLookup auth.curfragment addr
         nextnode = arrayLookup auth.nextnode addr
         numnodes = arrayLookup auth.numnodes frag
         matches = addr_matches && node_matches
         address = arrayLookup auth.addresses frag
         addr_matches = Values::addressobj_eq addr address
         node_matches = match_node heap auth frag nextnode args

   /*
    * Try matching the current fragment. If that works, move to the
    * next node and succeed. If not, finish the fragment, and try
    * again, until we run out of fragments.
    *
    * Return an updated Auth state as well as success/failure.
    *
    * Termination: if advance_to_next_fragment works right, it always
    * increments the address's entry in auth.curfragment at least
    * once, and it will therefore eventually exceed auth.numfragments
    * and at that point we stop.
    */
   check_fragment: Heap -> Auth -> Addr -> ArgBundle -> (Auth, Bool)
   check_fragment heap auth addr args =
      // try the active fragment
      if matches then to_nextnode else retry_nextfrag
      where
         matches = match_fragment heap auth addr args
         // the active fragment matched, advance to its next node
         // and succeed
         to_nextnode = (auth', True)
            where auth' = advance_to_next_node auth addr
         // the active fragment didn't match; drop it and move to the next
         retry_nextfrag =
            if ran_out then (auth', False)
            else check_fragment heap auth' addr args
            where
               auth' = finish_fragment auth addr
               ran_out = arrayLookup auth.curfragment addr >= auth.numfragments

/*
 * Check whether the invoked function and args are authorized. Returns
 * an updated authorization state as well as the success/failure
 * result.
 */
check_noargs: Heap -> Auth -> Addr -> (Auth, Bool)
check_noargs heap auth addr = check_fragment heap auth addr auth.invokedargs

/*
 * Similar but with an explicit arglist.
 */
check_withargs: Heap -> Auth -> Addr -> Values::VecObject::T -> (Auth, Bool)
check_withargs heap auth addr args = check_fragment heap auth addr args'
   where args' = argbundle_of_vecobj heap args
