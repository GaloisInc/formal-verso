module Symbol where

import Option as Option
import RawVal as RawVal
import Tag as Tag
import Body as Body

newtype Symbol = { raw : RawVal::T }
type T = Symbol

valid_raw : RawVal::T -> Bit
valid_raw rv = RawVal::has_tag Tag::symbol_small rv
            \/ RawVal::has_tag Tag::symbol_object rv

unsafe_from_raw : RawVal::T -> Symbol
unsafe_from_raw rv = Symbol { raw = rv }

from_raw : RawVal::T -> Option::T Symbol
from_raw rv = Option::mk (valid_raw rv) (unsafe_from_raw rv)

encode_char : Char -> [6]
encode_char ch =
  if ch == '_' then 1
  | elem ch ['0'..'9'] then 2 + drop (ch - '0')
  | elem ch ['A'..'Z'] then 12 + drop (ch - 'A')
  | elem ch ['a'..'z'] then 38 + drop (ch - 'a')
  else error
    ("symbol bad char: encountered " # [ch]
      # ", supported range [a-zA-Z0-9_]")

valid : Symbol -> Bit
valid w = valid_raw w.raw

short : {n} (n <= 9) => String n -> Symbol
short s = unsafe_from_raw (RawVal::from_body_and_tag body Tag::symbol_small)
   where body = zext (join (map encode_char s))
