/*
 * Soroban SDK values.
 *
 * This is intentionally supposed to have the same bit encoding as the
 * Soroban SDK. See src/val.rs in soroban-env-common, plus also a few
 * other modules like num.rs.
 *
 * Values are a tagged union stored in a 64-bit machine integer, where
 * the lower 8 bits are used as a type tag. The remaining 56 bits are
 * (in some cases) divided into a 32-bit major part and 24-bit minor
 * part. The major part is the upper half of the full 64-bit value.
 * That is:
 *      63       32  31        8  7       0
 *     |-- major --||-- minor --||-- tag --|
 *
 * The type Val is this type-tagged representation of any Soroban
 * value.
 *
 * The following types are wrappers around it theoretically restricted
 * to the values corresponding to their type, as in the Rust code:
 *    Void::T
 *    Bool::T
 *    U32::T
 *     :
 *
 * The layout of this module is intended to mirror val.rs, though it's
 * difficult to do exactly.
 *
 * Also, my intent is to not let the type tags escape from this module,
 * which is somewhat in conflict with the desire to match val.rs.
 *
 * Note: i'm using math ints for bit sizes and widths, not because
 * they need to be unbounded, but in the hopes that accidentally
 * mixing sizes with values or pieces of values will reliably lead to
 * type errors.
 */

module Values where

import Option as Option

////////////////////////////////////////////////////////////
// fields
// val.rs lines 20-41

// Sizes
private
   type WORD_BITS  = 64
   type TAG_BITS   =  8
   type BODY_BITS  = 56
   type MAJOR_BITS = 32
   type MINOR_BITS = 24

// trivial but worth stating and crosschecking
property BODY_TAG_WORD_BITS    = `BODY_BITS  + `TAG_BITS   == `WORD_BITS
property MAJOR_MINOR_BODY_BITS = `MAJOR_BITS + `MINOR_BITS == `BODY_BITS
// apparently you can't do this except by loading the file and running
// :prove from the repl :-(
//prove MAJOR_MINOR_BODY_BITS
//prove BODY_TAG_WORD_BITS

// Masks
//
// In keeping with tag.rs we'll use FOO_MASK to mean a right-aligned
// mask of the proper size; the intended usage for extracting a field
// is apparently
//    (val >> shift-amount) && FOO_MASK
// but val.rs doesn't seem to define constants for the shift amounts.
//
// We'll also define FOO_SHIFT as the shift amounts.
//

private
   mask_of_width : Integer -> [64]
   mask_of_width w = (1 << w) - 1

   TAG_MASK   = mask_of_width `TAG_BITS
   BODY_MASK  = mask_of_width `BODY_BITS
   MAJOR_MASK = mask_of_width `MAJOR_BITS
   MINOR_MASK = mask_of_width `MINOR_BITS

   TAG_SHIFT   = 0 : Integer
   BODY_SHIFT  = `TAG_BITS
   MAJOR_SHIFT = `MINOR_BITS + `TAG_BITS
   MINOR_SHIFT = `TAG_BITS

// check these came out as expected
property TAG_MASK_BITS   = TAG_MASK   == 0x00000000000000ff
property BODY_MASK_BITS  = BODY_MASK  == 0x00ffffffffffffff
property MAJOR_MASK_BITS = MAJOR_MASK == 0x00000000ffffffff
property MINOR_MASK_BITS = MINOR_MASK == 0x0000000000ffffff
property TAG_MASK_SHIFTED   = (TAG_MASK << TAG_SHIFT)     == 0x00000000000000ff
property BODY_MASK_SHIFTED  = (BODY_MASK << BODY_SHIFT)   == 0xffffffffffffff00
property MAJOR_MASK_SHIFTED = (MAJOR_MASK << MAJOR_SHIFT) == 0xffffffff00000000
property MINOR_MASK_SHIFTED = (MINOR_MASK << MINOR_SHIFT) == 0x00000000ffffff00
//prove TAG_MASK_BITS
//prove BODY_MASK_BITS
//prove MAJOR_MASK_BITS
//prove MINOR_MASK_BITS
//prove TAG_MASK_SHIFTED
//prove BODY_MASK_SHIFTED
//prove MAJOR_MASK_SHIFTED
//prove MINOR_MASK_SHIFTED


////////////////////////////////////////////////////////////
// type tags
// val.rs 42-157

private
   type Tag = [TAG_BITS]

/*
 * These magic numbers are the ones used in val.rs.
 *
 * Commented-out ones are those we don't use yet.
 */

private
   tag_false = 0 : Tag
   tag_true = 1 : Tag
   tag_void = 2 : Tag
   //tag_error = 3 : Tag
   tag_u32val = 4 : Tag
   tag_i32val = 5 : Tag
   //tag_u64small = 6 : Tag
   //tag_i64small = 7 : Tag
   //tag_timepointsmall = 8 : Tag
   //tag_durationsmall = 9 : Tag
   //tag_u128small = 10 : Tag
   //tag_i128small = 11 : Tag
   //tag_u256small = 12 : Tag
   //tag_i256small = 13 : Tag
   tag_symbolsmall = 14 : Tag

   // upper bound of "small" types and lower bound of "object" types
   // (these are called "code" rather than "tag" in the sdk source;
   // for now at least I'm proceeding on the assumption that the lack
   // of correspondence between here and there is less important than
   // consistency of naming here)
   small_tag_upper_bound = 15 : Tag
   object_tag_lower_bound = 63 : Tag

   //tag_u64object = 64 : Tag
   //tag_i64object = 65 : Tag
   //tag_timepointobject = 66 : Tag
   //tag_durationobject = 67 : Tag
   //tag_u128object = 68 : Tag
   //tag_i128object = 69 : Tag
   //tag_u256object = 70 : Tag
   //tag_i256object = 71 : Tag
   //tag_bytesobject = 72 : Tag
   //tag_stringobject = 73 : Tag
   tag_symbolobject = 74 : Tag
   //tag_vecobject = 75 : Tag
   tag_mapobject = 76 : Tag
   //tag_addressobject = 77 : Tag

   // correspondingly, upper bound of "object" types
   object_tag_upper_bound = 78 : Tag

   // tag for invalid values
   badtag = 0x7f : Tag

//
// checks on type tags
//

// val.rs lines 170-178
private
   tag_is_object : Tag -> Bool
   tag_is_object x =
      (x > object_tag_lower_bound) && (x < object_tag_upper_bound)


////////////////////////////////////////////////////////////
// values

// XXX can't make it private; using an accessor function in
// to_mir_value in soroban.saw breaks SAW.
//private
newtype Val = { bits: [WORD_BITS] }

//
// You can't (yet) derive typeclass instances for newtypes, so until
// then we need this (and to use it explicitly where it would be nicer
// to write "==")
private
   val_eq : Val -> Val -> Bool
   val_eq v1 v2 = v1.bits == v2.bits

/*
 * I am not transcribing the assorted Rust type widgetry since
 * it mostly doesn't make sense in Cryptol.
 */

/*
 * Field extraction functions
 * (these don't neatly correspond to anything in the rust code)
 */

private
   body_of_val : Val -> [BODY_BITS]
   body_of_val v = drop ((v.bits >> BODY_SHIFT) && BODY_MASK)

   tag_of_val : Val -> Tag
   tag_of_val v = drop ((v.bits >> TAG_SHIFT) && TAG_MASK)

   major_of_val : Val -> [MAJOR_BITS]
   major_of_val v = drop ((v.bits >> MAJOR_SHIFT) && MAJOR_MASK)

   minor_of_val : Val -> [MINOR_BITS]
   minor_of_val v = drop ((v.bits >> MINOR_SHIFT) && MINOR_MASK)

/*
 * Construction functions
 * (likewise)
 */
private
   val_of_body_tag : [56] -> Tag -> Val
   val_of_body_tag body tag =
      Val { bits = (body' || tag') }
      where
         body' = zext`{64} body << BODY_SHIFT
         tag' = zext`{64} tag << TAG_SHIFT

   val_of_major_minor_tag : [32] -> [24] -> Tag -> Val
   val_of_major_minor_tag major minor tag =
      Val { bits = (major' || minor' || tag') }
      where
         major' = zext`{64} major << MAJOR_SHIFT
         minor' = zext`{64} minor << MINOR_SHIFT
         tag' = zext`{64} tag << TAG_SHIFT

/*
 * Constructors and constants
 */

private
   badval = val_of_body_tag 0 badtag

// val.rs line 249
submodule Raw where
   type T = Val

   /*
    * Inspection functions
    */

   // val.rs lines 685-688
   get_payload : T -> [64]
   get_payload x = x.bits

   // val.rs lines 690-693
   from_payload : [64] -> T
   from_payload x = Val { bits = x }

   // val.rs lines 685-688
   shallow_eq : T -> T -> Bool
   shallow_eq x y = x.bits == y.bits

   // val.rs lines 726-729
   has_tag : Tag -> T -> Bool
   has_tag t rv = get_tag rv == t

   //from_symbol_small : Body::T -> RawVal
   //from_symbol_small body = from_body_and_tag body tag_symbolsmall

   // val.rs lines 731-736
   from_body_and_tag : [BODY_BITS] -> Tag -> T
   from_body_and_tag body tag = val_of_body_tag body tag

   // val.rs lines 738-744
   from_major_minor_and_tag : [MAJOR_BITS] -> [MINOR_BITS] -> Tag -> T
   from_major_minor_and_tag major minor tag =
      val_of_major_minor_tag major minor tag

   singleton : Tag -> T
   singleton = from_body_and_tag 0

   get_tag : T -> Tag
   get_tag v = tag_of_val v

   get_body : T -> [BODY_BITS]
   get_body v = body_of_val v

   get_major : T -> [MAJOR_BITS]
   get_major v = major_of_val v

   get_minor : T -> [MINOR_BITS]
   get_minor v = minor_of_val v

import submodule Raw as Raw

////////////////////////////////////////////////////////////
// void

submodule Void where
   newtype Void = { raw : Raw::T }
   type T = Void

   raw_void : Raw::T
   raw_void = Raw::singleton tag_void

   valid_raw v = val_eq v raw_void

   unsafe_from_raw : Raw::T -> Void
   unsafe_from_raw rv = Void { raw = rv }

   void : Void
   void = unsafe_from_raw raw_void

   from_raw : Raw::T -> Option::T Void
   from_raw rv = Option::mk (valid_raw rv) (unsafe_from_raw rv)

   to_raw : Void -> Raw::T
   to_raw w = w.raw

   valid : Void -> Bit
   valid w = valid_raw w.raw

import submodule Void as Void

unit = Void::void


////////////////////////////////////////////////////////////
// bool

submodule Bool where
   newtype Bool = { raw : Raw::T }
   type T = Bool

   raw_true : Raw::T
   raw_true = Raw::singleton tag_true

   raw_false : Raw::T
   raw_false = Raw::singleton tag_false

   raw_from_bit : Bit -> Raw::T
   raw_from_bit b = if b then raw_true else raw_false

   valid_raw v = val_eq v raw_true \/ val_eq v raw_false

   unsafe_from_raw : Raw::T -> Bool
   unsafe_from_raw rv = Bool { raw = rv }

   from_raw : Raw::T -> Option::T Bool
   from_raw rv = Option::mk (valid_raw rv) (unsafe_from_raw rv)

   to_raw : Bool -> Raw::T
   to_raw w = w.raw

   valid : Bool -> Bit
   valid w = valid_raw w.raw

   to_bit : Bool -> Bit
   to_bit v = Raw::shallow_eq (to_raw v) raw_true

   from_bit : Bit -> Bool
   from_bit b = unsafe_from_raw (raw_from_bit b)

import submodule Bool as Bool

////////////////////////////////////////////////////////////
// u32

submodule U32 where
   to_raw : [32] -> Raw::T
   to_raw u = Raw::from_major_minor_and_tag u 0 tag_u32val

   is_u32 : Raw::T -> Bit
   is_u32 rv = Raw::has_tag tag_u32val rv /\ Raw::get_minor rv == 0

   from_raw : Raw::T -> Option::T [32]
   from_raw rv = Option::mk (is_u32 rv) (Raw::get_major rv)

import submodule U32 as U32

////////////////////////////////////////////////////////////
// symbol

submodule Symbol where
   newtype Symbol = { raw : Raw::T }
   type T = Symbol

   valid_raw : Raw::T -> Bit
   valid_raw rv = Raw::has_tag tag_symbolsmall rv
               \/ Raw::has_tag tag_symbolobject rv

   unsafe_from_raw : Raw::T -> Symbol
   unsafe_from_raw rv = Symbol { raw = rv }

   from_raw : Raw::T -> Option::T Symbol
   from_raw rv = Option::mk (valid_raw rv) (unsafe_from_raw rv)

   encode_char : Char -> [6]
   encode_char ch =
     if ch == '_' then 1
     | elem ch ['0'..'9'] then 2 + drop (ch - '0')
     | elem ch ['A'..'Z'] then 12 + drop (ch - 'A')
     | elem ch ['a'..'z'] then 38 + drop (ch - 'a')
     else error
       ("symbol bad char: encountered " # [ch]
         # ", supported range [a-zA-Z0-9_]")

   valid : Symbol -> Bit
   valid w = valid_raw w.raw

   short : {n} (n <= 9) => String n -> Symbol
   short s = unsafe_from_raw (Raw::from_body_and_tag body tag_symbolsmall)
      where body = zext (join (map encode_char s))

import submodule Symbol as Symbol

////////////////////////////////////////////////////////////
// vecobject
// val.rs line 330

// TBD

////////////////////////////////////////////////////////////
// mapobject
// val.rs line 331

// TBD

////////////////////////////////////////////////////////////
// addressobject
// val.rs line 332

// TBD

////////////////////////////////////////////////////////////
// workarounds for saw-script #1964
// (cannot refer to cryptol submodule elements directly)
type VoidT = Void::T
type BoolT = Bool::T
type U32T = /*U32::T*/ [32]
type SymbolT = Symbol::T
type RawT = Raw::T

bool_from_native = Bool::from_bit
symbol_from_native = Symbol::short

void_from_raw = Void::from_raw
bool_from_raw = Bool::from_raw
u32_from_raw = U32::from_raw
symbol_from_raw = Symbol::from_raw

u32_to_raw = U32::to_raw

raw_from_payload = Raw::from_payload
raw_get_payload = Raw::get_payload
