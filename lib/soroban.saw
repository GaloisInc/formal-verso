enable_experimental;

typedef SorobanCry = {
  RawVal : CryptolModule,
  Storage : CryptolModule,
  Symbol : CryptolModule
};

typedef SorobanAdt = {
  Guest : MIRAdt,
  Env : MIRAdt,
  MaybeEnv : MIRAdt,
  Storage : MIRAdt,
  Symbol : MIRAdt,
  RawVal : MIRAdt,
  SymbolVal : MIRAdt
};

typedef SorobanSpecAPI = {

  storage : {
    state : (Term /* Storage */ -> MIRSetup ()),
    has : (Term /* Storage */ -> Term /* k */ -> Term /* Bit */),
    get : (Term /* Storage */ ->
      Term /* k */ -> Type /* = v */ -> Term /* Option (Option v) */),
    set : (Term /* Storage */ ->
      Term /* k */ -> Term /* v */ -> Term /* Storage */)
  },

  fresh : (String -> Type -> MIRSetup Term),

  mir_value : {
    Guest : MIRValue,
    Env : MIRValue,
    MaybeEnv : MIRValue,
    Storage : MIRValue
  },
  to_mir_value : (Term -> MIRValue),
  to_mir_type : (Type -> MIRType)

};

typedef SorobanGenericSdkSpecs = {
  storage : {
    set : (Type -> Type -> MIRSetup ())
  }
};

typedef SorobanPrepareVerifyArgs = {
  instantiate : [(String, MIRSetup ())]
};

typedef SorobanVerifyArgs = {
  fun : String,
  overrides : [MIRSpec],
  path_sat : Bool,
  spec : MIRSetup (),
  proof : ProofScript ()
};

typedef SorobanVerify = SorobanVerifyArgs -> TopLevel MIRSpec;

typedef SorobanAPI = {
  cry: SorobanCry,
  adt : SorobanAdt,
  spec : (String -> (SorobanSpecAPI -> MIRSetup ()) -> MIRSetup ()),
  generic_sdk_specs : SorobanGenericSdkSpecs,
  prepare_verify : (SorobanPrepareVerifyArgs -> TopLevel SorobanVerify)
};

soroban_init <- do {

  Option <- cryptol_load "Option.cry";
  RawVal <- cryptol_load "RawVal.cry";
  Storage <- cryptol_load "Storage.cry";
  Symbol <- cryptol_load "Symbol.cry";
  U32 <- cryptol_load "U32.cry";
  Util <- cryptol_load "Util.cry";

  let soroban_init (mod : MIRModule) : TopLevel SorobanAPI = do {

    state <- do {
      storage <- declare_ghost_state "Soroban::storage";
      return {
        storage = storage
      };
    };

    let soroban_adt : SorobanAdt = {
      Guest = mir_find_adt mod "soroban_env_guest::guest::Guest" [],
      Env = mir_find_adt mod "soroban_sdk::env::Env" [],
      MaybeEnv = mir_find_adt mod "soroban_sdk::env::MaybeEnv" [],
      Storage = mir_find_adt mod "soroban_sdk::storage::Storage" [],
      Symbol = mir_find_adt mod "soroban_sdk::symbol::Symbol" [],
      RawVal = mir_find_adt mod "soroban_env_common::raw_val::RawVal" [],
      SymbolVal = mir_find_adt mod "soroban_env_common::symbol::Symbol" []
    };

    let mir_value =
      let mir_value_Guest =
        mir_struct_value soroban_adt.Guest [] in
      let mir_value_Env =
        mir_struct_value soroban_adt.Env [mir_value_Guest] in
      let mir_value_MaybeEnv =
        mir_struct_value soroban_adt.MaybeEnv [mir_value_Guest] in
      let mir_value_Storage =
        mir_struct_value soroban_adt.Storage [mir_value_Env] in
      {
        Guest = mir_value_Guest,
        Env = mir_value_Env,
        MaybeEnv = mir_value_MaybeEnv,
        Storage = mir_value_Storage
      };

    let type_eq (t1 : Type) (t2 : Type) : Bool =
      let s1 = show t1 in
      let s2 = show t2 in
      eval_bool {{ Util::lenPolyEq s1 s2 }};

    let to_raw (t : Type) : Term /* t -> RawVal */ =
      if type_eq t {| [32] |} then
        {{ U32::to_raw }}
      else if type_eq t {| Symbol::T |} then
        {{ \(s : Symbol::T) -> s.raw }}
      else
        run (fail (str_concat (show t) " cannot be converted to RawVal"));

    let from_raw (t : Type) : Term /* RawVal -> Option t */ =
      if type_eq t {| [32] |} then
        {{ U32::from_raw }}
      else if type_eq t {| Symbol::T |} then
        {{ Symbol::from_raw }}
      else
        run (fail (str_concat (show t) " cannot be converted from RawVal"));

    let type_valid (t : Type) : Term /* t -> Bit */ =
      if type_eq t {| Symbol::T |} then
        {{ Symbol::valid }}
      else
        // default to no conditions
        {{ \_ -> True }};

    rec to_mir_value x =
      let t = type x in
      if type_eq t {| RawVal::T |} then
        mir_struct_value soroban_adt.RawVal [
          mir_term {{ x.payload }}
        ]
      else if type_eq t {| Symbol::T |} then
        mir_struct_value soroban_adt.Symbol [
          mir_value.MaybeEnv,
          mir_struct_value soroban_adt.SymbolVal [
            to_mir_value {{ x.raw }}
          ]
        ]
      else
        // fall back to mir_term
        mir_term x;

    let to_mir_type t =
      if type_eq t {| [32] |} then
        mir_u32
      else if type_eq t {| RawVal::T |} then
        mir_adt soroban_adt.RawVal
      else if type_eq t {| Symbol::T |} then
        mir_adt soroban_adt.Symbol
      else
        run (fail (str_concat (show t) " cannot be converted to MIRType"));

    let spec_storage = {

      state = \storage -> do {
        mir_ghost_value state.storage storage;
      },

      has = \storage k ->
        let k_to_raw = to_raw (type k) in
        {{ Storage::has storage (k_to_raw k) }},

      get = \storage k tv ->
        let k_to_raw = to_raw (type k) in
        let v_from_raw = from_raw tv in
        {{ Option::fmap
            (Storage::get storage (k_to_raw k))
            v_from_raw }},

      set = \storage k v ->
        let k_to_raw = to_raw (type k) in
        let v_to_raw = to_raw (type v) in
        {{ Storage::set storage (k_to_raw k) (v_to_raw v) }}

    };

    let soroban_spec spec_name spec = do {

      spec {

        storage = spec_storage,

        fresh = \name t -> do {
          x <- mir_fresh_cryptol_var (str_concats [spec_name, "::", name]) t;
          let valid = type_valid t;
          mir_assert {{ valid x }};
          return x;
        },

        mir_value = mir_value,

        to_mir_value = to_mir_value,
        to_mir_type = to_mir_type

      };

    };

    let mono_sdk_specs = {

      storage = {

        has_internal = soroban_spec "soroban_sdk::storage::has_internal"
          (\(s : SorobanSpecAPI) -> do {

            storage <- s.fresh "storage" {| Storage::T |};

            self <- mir_alloc (mir_adt soroban_adt.Storage);
            mir_points_to self (s.mir_value.Storage);

            key <- s.fresh "key" {| RawVal::T |};

            s.storage.state storage;

            mir_execute_func [self, s.to_mir_value key];

            s.storage.state storage;

            mir_return (mir_term {{ Storage::has storage key }});

          }),

        get_internal = soroban_spec "soroban_sdk::storage::get_internal"
          (\(s : SorobanSpecAPI) -> do {

            storage <- s.fresh "storage" {| Storage::T |};

            self <- mir_alloc (mir_adt soroban_adt.Storage);
            mir_points_to self (s.mir_value.Storage);

            key <- s.fresh "key" {| RawVal::T |};

            mir_precond {{ Storage::has storage key }};
            s.storage.state storage;

            mir_execute_func [self, s.to_mir_value key];

            s.storage.state storage;

            mir_return (s.to_mir_value {{ (Storage::get storage key).value }});

          })

      }

    };

    let generic_sdk_specs = {

      storage = {

        set = \tk tv -> soroban_spec
          (str_concats
            ["soroban_sdk::storage::set<", show tk, ", ", show tv, ">"])
          (\(s : SorobanSpecAPI) -> do {

            storage <- s.fresh "storage" {| Storage::T|};

            self <- mir_alloc (mir_adt soroban_adt.Storage);
            mir_points_to self (s.mir_value.Storage);

            key <- s.fresh "key" tk;
            let key_mir = s.to_mir_value key;
            rkey <- mir_alloc (s.to_mir_type tk);
            mir_points_to rkey key_mir;

            val <- s.fresh "val" tv;
            let val_mir = s.to_mir_value val;
            rval <- mir_alloc (s.to_mir_type tv);
            mir_points_to rval val_mir;

            s.storage.state storage;

            mir_execute_func [self, rkey, rval];

            s.storage.state (s.storage.set storage key val);

          })

      }

    };

    let unsafe_assume_specs (specs : [(String, MIRSetup ())]) =
      for specs (\(name, spec) -> mir_unsafe_assume_spec mod name spec);

    mono_sdk_overrides <- unsafe_assume_specs [
      ("soroban_sdk::storage::{impl#1}::has_internal",
        mono_sdk_specs.storage.has_internal),
      ("soroban_sdk::storage::{impl#1}::get_internal",
        mono_sdk_specs.storage.get_internal)
    ];

    let soroban_verify sdk_overrides (args : SorobanVerifyArgs) = do {
      mir_verify mod args.fun (concat sdk_overrides args.overrides)
        args.path_sat args.spec args.proof;
    };

    return {

      cry = {
        RawVal = RawVal,
        Storage = Storage,
        Symbol = Symbol
      },

      adt = soroban_adt,

      spec = soroban_spec,

      generic_sdk_specs = generic_sdk_specs,

      prepare_verify = \(args : SorobanPrepareVerifyArgs) -> do {
        inst_sdk_overrides <- unsafe_assume_specs args.instantiate;
        return (soroban_verify (concat mono_sdk_overrides inst_sdk_overrides));
      }

    };

  };

  return soroban_init;

};
