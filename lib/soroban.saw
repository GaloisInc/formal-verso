enable_experimental;

include "list.saw";

/*
 * Load the cryptol modules.
 */

Util <- cryptol_load "Util.cry";
Option <- cryptol_load "Option.cry";
Values <- cryptol_load "Values.cry";
Store <- cryptol_load "Store.cry";


////////////////////////////////////////////////////////////
// MIR symbols

/*
 * Symbols extracted from the MIR
 */
typedef SorobanMIRItems = {
   // non-soroban
   InfallibleType : (() -> MIRAdt),
   ResultInfallibleType : (MIRType -> MIRAdt),

   // from the soroban_env_guest crate
   GuestType : (() -> MIRAdt),
   GuestVal : (() -> MIRValue),

   // from the soroban_sdk crate
   EnvType : (() -> MIRAdt),
   EnvVal : (() -> MIRValue),
   MaybeEnvType : (() -> MIRAdt),
   MaybeEnvVal : (() -> MIRValue),
   StorageType : (() -> MIRAdt),
   StorageVal : (() -> MIRValue),
   SymbolType : (() -> MIRAdt),

   // from the soroban_env_common crate
   VoidType : (() -> MIRAdt),
   BoolType : (() -> MIRAdt),
   U32ValType : (() -> MIRAdt),
   SymbolValType : (() -> MIRAdt),
   RawValType : (() -> MIRAdt)
};

let make_soroban_mir_items mod features : SorobanMIRItems =
   /*
    * Tools for looking up stuff in the MIR.
    */
   let find_adt adt_name =
     let adt = mir_find_adt mod adt_name [] in
     \() -> adt
   in
   let find_adt_when feat adt_name =
     if string_list.elem feat features then
       find_adt adt_name
     else
       \() -> run (fail (str_concats [
         "Feature \"", feat, "\" is required for type ", adt_name
       ]))
   in

   /*
    * Bind handles for various SDK types and values.
    *
    * These bindings are delayed so we don't crash looking for
    * things that might not exist in the test MIR until something
    * explicitly asks for them.
    *
    * XXX: seems like we don't need both the delay behavior and
    * the features list. Simplify?
    */

   // non-soroban
   let InfallibleType = find_adt "core::convert::Infallible" in
   let ResultInfallibleType (t : MIRType) =
      mir_find_adt mod "core::result::Result" [t, mir_adt (InfallibleType ())]
   in

   // from the soroban_env_guest crate
   let GuestType = find_adt "soroban_env_guest::guest::Guest" in
   let GuestVal () = mir_struct_value (GuestType ()) [] in

   // from the soroban_sdk crate
   let EnvType = find_adt "soroban_sdk::env::Env" in
   let EnvVal () = mir_struct_value (EnvType ()) [GuestVal ()] in
   let MaybeEnvType = find_adt_when "maybe_env" "soroban_sdk::env::MaybeEnv" in
   let MaybeEnvVal () = mir_struct_value (MaybeEnvType ()) [GuestVal ()] in
   let StorageType = find_adt_when "storage" "soroban_sdk::storage::Storage" in
   let StorageVal () = mir_struct_value (StorageType ()) [EnvVal ()] in
   let SymbolType = find_adt_when "symbol" "soroban_sdk::symbol::Symbol" in

   // from the soroban_env_common crate
   let VoidType = find_adt_when "void_val" "soroban_env_common::raw_val::Void" in
   let BoolType = find_adt_when "bool_val" "soroban_env_common::raw_val::Bool" in
   let U32ValType = find_adt_when "u32_val" "soroban_env_common::num::U32Val" in
   let SymbolValType = find_adt_when "symbol" "soroban_env_common::symbol::Symbol" in
   let RawValType = find_adt "soroban_env_common::raw_val::RawVal" in

   {
      InfallibleType = InfallibleType,
      ResultInfallibleType = ResultInfallibleType,

      // from the soroban_env_guest crate
      GuestType = GuestType,
      GuestVal = GuestVal,

      // from the soroban_sdk crate
      EnvType = EnvType,
      EnvVal = EnvVal,
      MaybeEnvType = MaybeEnvType,
      MaybeEnvVal = MaybeEnvVal,
      StorageType = StorageType,
      StorageVal = StorageVal,
      SymbolType = SymbolType,

      // from the soroban_env_common crate
      VoidType = VoidType,
      BoolType = BoolType,
      U32ValType = U32ValType,
      SymbolValType = SymbolValType,
      RawValType = RawValType
   };


////////////////////////////////////////////////////////////
// Top-level context

/*
 * Material returned by the init function for use by the actual specs:
 *    - the MIR module
 *    - references to MIR symbols from the SDK
 *    - overrides list for functions from the SDK
 */
typedef SorobanAPI = {
   mod : MIRModule,
   smi : SorobanMIRItems,
   sdk_overrides : [MIRSpec]
};


////////////////////////////////////////////////////////////
// SDK value interface

/*
 * Hook for dynamic type dispatch on the value types.
 *
 * This should really be module-private if there were such a thing.
 */
let type_eq (t1 : Type) (t2 : Type) : Bool =
   let s1 = show t1 in
   let s2 = show t2 in
   eval_bool {{ Util::lenPolyEq s1 s2 }};

/*
 * Check if a value of a value type is actually a valid value of
 * that type. In theory, we shouldn't ever attach types to invalid
 * values; we shouldn't ever construct any and potentially-garbage
 * values from outside should appear first as Values::Raw and get
 * checked before being converted to a specific value type.
 *
 * However, the Soroban SDK rust code plays fast and loose with
 * unsafe casts and we want to interoperate with it as much as
 * possible.
 *
 * The real type is:
 *    soroban_value_valid : (t : Type) -> t -> Bit
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_valid (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_valid }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_valid }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_valid }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_valid }}
   else if type_eq t {| Values::RawT |} then
      {{ Values::raw_valid }}
   else if type_eq t {| Store::T |} then
      // XXX: this gets passed here, but shouldn't be. ignore it for now
      // (this logic is for value types!)
      {{ \_ -> True }}
   else
      run (fail (str_concat (show t) " has no validity predicate"));

/*
 * Generate a fresh var of the requested value type.
 *
 * Note: only for value types.
 *
 * Note: we used to cons the name of the current spec onto the name
 * passed in. We don't do that any more because it requires all kinds
 * of contortions to remember the name in a useful way.
 */
let soroban_value_fresh (name : String) (t : Type) : MIRSetup Term = do {
   //let name' = str_concats [spec_name, "::", name];
   x <- mir_fresh_cryptol_var name t;
   let t_valid = soroban_value_valid t;
   mir_assert {{ t_valid x }};
   return x;
};

/*
 * Convert from a specific value type to Values::Raw::T.
 * Value types only.
 *
 * The real type is:
 *    soroban_value_to_raw : (t : Type) -> t -> Values::Raw::T
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_to_raw (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_to_raw }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_to_raw }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_to_raw }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_to_raw }}
   else
      run (fail (str_concat (show t) " cannot be converted to Raw"));

/*
 * Convert from a Values::Raw::T to a specific value type
 * (type is passed as the first argument)
 *
 * Returns None if the raw value is not actually a value
 * of the right type. Crashes if the type is wrong.
 *
 * The real type is:
 *    soroban_value_from_raw : (t : Type) -> Values::Raw::T -> Option::T t
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_from_raw (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_from_raw }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_from_raw }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_from_raw }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_from_raw }}
   else
      run (fail (str_concat (show t) " cannot be converted from Raw"));

/*
 * Extract the MIR-level type for type T. Value types only.
 *
 * This function is the type-level version of soroban_value_to_mir.
 */
let soroban_value_type_to_mir (smi : SorobanMIRItems) t =
   if type_eq t {| Values::VoidT |} then
      mir_adt (smi.VoidType ())
   else if type_eq t {| Values::BoolT |} then
      mir_adt (smi.BoolType ())
   else if type_eq t {| Values::U32T |} then
      mir_adt (smi.U32ValType ())
   else if type_eq t {| Values::SymbolT |} then
      mir_adt (smi.SymbolType ())
   else if type_eq t {| Values::RawT |} then
      mir_adt (smi.RawValType ())
   else
      run (fail (str_concat (show t) " cannot be converted to MIRType"));

/*
 * Convert a value of a value type (recall the value types are
 * Cryptol types and have Cryptol values) to a mir_term.
 *
 * The MIR term we want is the corresponding tree of constructors
 * from the Rust side. There are two ways to do this: we can
 * extract the semantic value from the Cryptol term (e.g. unit,
 * True, False, 131, "hello", or whatever), convert that to its
 * Rust/MIR form, then create calls to the corresponding chain of
 * Rust constructors. Or, we can take advantage of having modeled
 * the internal representation used on the Rust side to just
 * extract the internal representation and transfer that across.
 *
 * There are at least three reasons to prefer the latter:
 *    - the internal representation is a u64 and is therefore
 *      easily moved across;
 *    - we can construct calls to arbitrary Rust functions if
 *      needed, but using them in spec-level logic is at least
 *      problematic (not sure whether it's allowed at all);
 *    - when we get to supporting object-style values, the
 *      external pointer part can just be pushed across as part
 *      of the u64 and we don't need to process the referent.
 *
 * In fact, I think this is why the Cryptol-level value logic was
 * built to match the internals of the Rust value logic.
 *
 * Ergo, the way this works is:
 *    - for types that aren't Values::Raw::T, recurse on the raw
 *      value and pass the results to the corresponding Rust
 *      constructor;
 *    - for Values::Raw::T, extract the bits of the representation
 *      and pass that to the Rust constructor.
 *
 * Note that for the latter case we need to fetch the bits
 * directly rather than calling the Cryptol-level accessor
 * function. Otherwise SAW loses track of the value when doing
 * override matching and the specs we produce don't work. See
 * saw-script #2035.
 *
 * For reasons I don't understand this seems to apply only to
 * the raw layer; the accessor functions for the wrapper types
 * seem to work ok.
 */
rec soroban_value_to_mir (smi : SorobanMIRItems) x =
   let t = type x in
   if type_eq t {| Values::VoidT |} then
      mir_struct_value (smi.VoidType ()) [
         soroban_value_to_mir smi {{ Values::void_to_raw x }}
      ]
   else if type_eq t {| Values::BoolT |} then
      mir_struct_value (smi.BoolType ()) [
         soroban_value_to_mir smi {{ Values::bool_to_raw x }}
      ]
   else if type_eq t {| Values::U32T |} then
      mir_struct_value (smi.U32ValType ()) [
         soroban_value_to_mir smi {{ Values::u32_to_raw x }}
      ]
   else if type_eq t {| Values::SymbolT |} then
      mir_struct_value (smi.SymbolType ()) [
         smi.MaybeEnvVal (),
         mir_struct_value (smi.SymbolValType ()) [
            soroban_value_to_mir smi {{ Values::symbol_to_raw x }}
         ]
      ]
   else if type_eq t {| Values::RawT |} then
      mir_struct_value (smi.RawValType ()) [
         // XXX: can't do this, it makes SAW unable to match specs
         //mir_term {{ Values::raw_get_payload x }}
         mir_term {{ x.bits }}
      ]
   else
      run (fail (str_concat (show t) " cannot be converted to a MIR value"));


////////////////////////////////////////////////////////////
// SDK storage interface

/*
 * Spec for the storage interface.
 *
 * To (maybe) improve clarity we refer to the moving parts of the
 * storage interface as follows:
 *    - "storage" is the name of the overall interface and concept
 *    - "store" is the name of the data structure we use to model the contents
 *
 * There are three parts to the code:
 *    - a Cryptol implementation of the store
 *    - a SAW wrapper around the Cryptol
 *    - SAW specs for the Rust interface
 *
 * Note that currently the model version of the code (the Cryptol and
 * the SAW wrapper) requires that contract specs explicitly update the
 * storage state after manipulating the store, but the Rust interface
 * specs (necessarily) do this internally. This is on the one hand
 * similar, but it also means that contract specs have to do extra
 * work/operations that have no equivalent in their Rust code and I'm
 * not sure that's a good way to do things. That is, I'm suggesting
 * that the SAW store ops below that just manipulate store values
 * should be extended to storage ops that update the state and thus
 * apply to the whole storage model. This wants some thought.
 *
 * For now at least the Cryptol-level store is written purely in terms
 * of Values::Raw::T and the type wrapping happens here. It's possible
 * that should change, but we'll see.
 */

/*
 * The model of the storage contents. Because the ghost state we keep
 * it in is mutable, it doesn't need to be passed around and can live
 * as a global here. Wrap it in a type to help prevent accidents.
 */
typedef SorobanStorageState = {
   ghoststate : Ghost
};

soroban_storage_state <- do {
   ghoststate <- declare_ghost_state "Soroban::storage";
   let state = {
      ghoststate = ghoststate
   };
   return state;
};

/*
 * Update the internally tracked model of the storage contents with a
 * new Store.
 */
let soroban_storage_update_state (store : Term /* Store */) : MIRSetup () = do {
   mir_ghost_value soroban_storage_state.ghoststate store;
};

/*
 * Ops on store values. These are basically type wrappers around
 * the Cryptol version of the Store.
 */

/*
 * Check if the a store has a given key. The key can be any value
 * type. Returns a Cryptol Bool.
 */
let soroban_store_has (store : Term /* Store */) (k : Term) =
   let k_to_raw = soroban_value_to_raw (type k) in
   {{ Store::has store (k_to_raw k) }};

/*
 * Get the contents in a store under a given key, as type tv.
 * The key can be any value type.
 *
 * Returns a Term with Cryptol type Option::T (Option::T tv).
 * If the outer Option is None, there was no such key in the store.
 * If the inner Option is None, the value found was not the expected type.
 *
 * (This is apparently the same interface as the SDK Rust code.)
 */
let soroban_store_get (store : Term /* Store */) (k : Term) (tv : Type) =
   let k_to_raw = soroban_value_to_raw (type k) in
   let v_from_raw = soroban_value_from_raw tv in
   {{ Option::fmap (Store::get store (k_to_raw k)) v_from_raw }};

/*
 * Set the contents in a store under a given key. The key and value
 * can be any value type.
 *
 * Returns a new Cryptol Store value.
 */
let soroban_store_set (store : Term /* Store */) (k : Term) (v : Term) =
   let k_to_raw = soroban_value_to_raw (type k) in
   let v_to_raw = soroban_value_to_raw (type v) in
   {{ Store::set store (k_to_raw k) (v_to_raw v) }};

/*
 * Specs for the SDK code.
 */

/*
 * Helper for returning Ok from a Rust function.
 */
let return_ok (smi : SorobanMIRItems) (x : Term) : MIRSetup () =
   mir_return
      (mir_enum_value
         (smi.ResultInfallibleType (soroban_value_type_to_mir smi (type x)))
         "Ok"
         [soroban_value_to_mir smi x]);

/*
 * Spec for has_contract_data()
 */
let storage_has_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.has.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.has.k" {| Values::RawT |};

   soroban_storage_update_state store;

   mir_execute_func [self, soroban_value_to_mir smi k];

   soroban_storage_update_state store;

   return_ok smi {{ Values::bool_from_native (Store::has store k) }};
};

/*
 * Spec for get_contract_data()
 */
let storage_get_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.get.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.get.k" {| Values::RawT |};

   // XXX is it really wrong to call get without first calling has?
   // seems unusual, and also inconsistent with the return type of
   // get.
   mir_precond {{ Store::has store k }};
   soroban_storage_update_state store;

   mir_execute_func [self, soroban_value_to_mir smi k];

   soroban_storage_update_state store;

   // XXX probably relatedly, this doesn't seem to be able to
   // return failure. But, this seems like it will do the wrong
   // thing if the type in the store is wrong...
   return_ok smi {{ (Store::get store k).value }};
};

/*
 * Spec for put_contract_data
 *
 * XXX: why are we calling our internal things "set" when the SDK uses "put"?
 */
let storage_put_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.put.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.put.k" {| Values::RawT |};
   v <- soroban_value_fresh "storage.put.v" {| Values::RawT |};

   soroban_storage_update_state store;

   let k_val = soroban_value_to_mir smi k;
   let v_val = soroban_value_to_mir smi v;
   mir_execute_func [self, k_val, v_val];

   soroban_storage_update_state {{ Store::set store k v }};

   // Return the SDK void value.
   return_ok smi {{ Values::unit }};
};

/*
 * Construct the "overrides" (checked or admitted SAW theorems, in
 * this case admitted) for the SDK storage interface.
 */
let make_storage_overrides (smi : SorobanMIRItems) mod features = do {
   if string_list.elem "storage" features then do {
      has_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::has_contract_data"
         (storage_has_spec smi);
      get_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::get_contract_data"
         (storage_get_spec smi);
      put_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::put_contract_data"
         (storage_put_spec smi);
      return [has_spec, get_spec, put_spec];
   }
   else
      return [];
};


////////////////////////////////////////////////////////////
// verify

/*
 * Args passed to verify
 */
typedef SorobanVerifyArgs = {
  fun : String,
  overrides : [MIRSpec],
  path_sat : Bool,
  spec : MIRSetup (),
  proof : ProofScript ()
};

/*
 * Hook for running verification
 */
let soroban_verify (soroban : SorobanAPI) (args : SorobanVerifyArgs) =
   mir_verify soroban.mod args.fun (concat soroban.sdk_overrides args.overrides)
        args.path_sat args.spec args.proof;

/*
 * Hook for assuming a specification instead
 * (intentionally has the same signature, even though some of it
 * isn't used)
 */
let soroban_assume (soroban : SorobanAPI) (args : SorobanVerifyArgs) =
   mir_unsafe_assume_spec soroban.mod args.fun args.spec;


////////////////////////////////////////////////////////////
// init

/*
 * Function to initialize the stuff in here.
 *
 * mod is the results of mir_load_module on the linked_mir.json file
 * containing the stuff we're trying to verify.
 *
 * The features list is a list of arbitrary strings naming things the
 * rust code is using; it prevents us from looking for MIR symbols
 * that don't exist. FUTURE: it should be a list of an enum type...
 */
let soroban_init (mod : MIRModule) (features : [String]) : TopLevel SorobanAPI = do {

   let feat_implies feats (x, y) =
      if string_list.elem x feats then concat [y] feats else feats;

   let features = list.foldl feat_implies features [
      ("storage", "bool_val"),
      ("storage", "void_val"),
      ("symbol", "maybe_env")
   ];

   let smi = make_soroban_mir_items mod features;

   storage_overrides <- make_storage_overrides smi mod features;

   return {
      mod = mod,
      smi = smi,
      sdk_overrides = storage_overrides
   };
};
