enable_experimental;

include "list.saw";

/*
 * Load the cryptol modules.
 */

Util <- cryptol_load "Util.cry";
Option <- cryptol_load "Option.cry";
Values <- cryptol_load "Values.cry";
Store <- cryptol_load "Store.cry";
Log <- cryptol_load "Log.cry";


////////////////////////////////////////////////////////////
// MIR symbols

/*
 * Symbols extracted from the MIR
 */
typedef SorobanMIRItems = {
   // non-soroban
   InfallibleType : (() -> MIRAdt),
   ResultInfallibleType : (MIRType -> MIRAdt),

   // from the soroban_env_guest crate
   GuestType : (() -> MIRAdt),
   GuestVal : (() -> MIRValue),

   // from the soroban_sdk crate
   EnvType : (() -> MIRAdt),
   EnvVal : (() -> MIRValue),
   MaybeEnvType : (() -> MIRAdt),
   MaybeEnvVal : (() -> MIRValue),
   StorageType : (() -> MIRAdt),
   StorageVal : (() -> MIRValue),
   SymbolType : (() -> MIRAdt),

   // from the soroban_env_common crate
   VoidType : (() -> MIRAdt),
   BoolType : (() -> MIRAdt),
   U32ValType : (() -> MIRAdt),
   SymbolValType : (() -> MIRAdt),
   VecObjectType : (() -> MIRAdt),
   RawValType : (() -> MIRAdt)
};

let make_soroban_mir_items mod features : SorobanMIRItems =
   /*
    * Tools for looking up stuff in the MIR.
    */
   let find_adt adt_name =
     let adt = mir_find_adt mod adt_name [] in
     \() -> adt
   in
   let find_adt_when feat adt_name =
     if string_list.elem feat features then
       find_adt adt_name
     else
       \() -> run (fail (str_concats [
         "Feature \"", feat, "\" is required for type ", adt_name
       ]))
   in

   /*
    * Bind handles for various SDK types and values.
    *
    * These bindings are delayed so we don't crash looking for
    * things that might not exist in the test MIR until something
    * explicitly asks for them.
    *
    * XXX: seems like we don't need both the delay behavior and
    * the features list. Simplify?
    *
    * XXX: also, while maybe there's some virtue to looking up types
    * in advance (so they only get looked up once each) I'm not sure
    * there's anything to be gained by having value construction
    * functions here vs. just calling them as needed.
    */

   // non-soroban
   let InfallibleType = find_adt "core::convert::Infallible" in
   let ResultInfallibleType (t : MIRType) =
      mir_find_adt mod "core::result::Result" [t, mir_adt (InfallibleType ())]
   in

   // from the soroban_env_guest crate
   let GuestType = find_adt "soroban_env_guest::guest::Guest" in
   let GuestVal () = mir_struct_value (GuestType ()) [] in

   // from the soroban_sdk crate
   let EnvType = find_adt "soroban_sdk::env::Env" in
   let EnvVal () = mir_struct_value (EnvType ()) [GuestVal ()] in
   let MaybeEnvType = find_adt_when "maybe_env" "soroban_sdk::env::MaybeEnv" in
   let MaybeEnvVal () = mir_struct_value (MaybeEnvType ()) [GuestVal ()] in
   let StorageType = find_adt_when "storage" "soroban_sdk::storage::Storage" in
   let StorageVal () = mir_struct_value (StorageType ()) [EnvVal ()] in
   let SymbolType = find_adt_when "symbol" "soroban_sdk::symbol::Symbol" in

   // from the soroban_env_common crate
   let VoidType = find_adt_when "void_val" "soroban_env_common::raw_val::Void" in
   let BoolType = find_adt_when "bool_val" "soroban_env_common::raw_val::Bool" in
   let U32ValType = find_adt_when "u32_val" "soroban_env_common::num::U32Val" in
   let SymbolValType = find_adt_when "symbol" "soroban_env_common::symbol::Symbol" in
   let VecObjectType = find_adt_when "vec_val" "soroban_env_common::raw_val::VecObject" in
   let RawValType = find_adt "soroban_env_common::raw_val::RawVal" in

   {
      InfallibleType = InfallibleType,
      ResultInfallibleType = ResultInfallibleType,

      // from the soroban_env_guest crate
      GuestType = GuestType,
      GuestVal = GuestVal,

      // from the soroban_sdk crate
      EnvType = EnvType,
      EnvVal = EnvVal,
      MaybeEnvType = MaybeEnvType,
      MaybeEnvVal = MaybeEnvVal,
      StorageType = StorageType,
      StorageVal = StorageVal,
      SymbolType = SymbolType,

      // from the soroban_env_common crate
      VoidType = VoidType,
      BoolType = BoolType,
      U32ValType = U32ValType,
      SymbolValType = SymbolValType,
      VecObjectType = VecObjectType,
      RawValType = RawValType
   };


////////////////////////////////////////////////////////////
// Top-level context

/*
 * Material returned by the init function for use by the actual specs:
 *    - the MIR module
 *    - references to MIR symbols from the SDK
 *    - overrides list for functions from the SDK
 */
typedef SorobanAPI = {
   mod : MIRModule,
   smi : SorobanMIRItems,
   sdk_overrides : [MIRSpec]
};


////////////////////////////////////////////////////////////
// SDK value interface

/*
 * Hook for dynamic type dispatch on the value types.
 *
 * This should really be module-private if there were such a thing.
 */
let type_eq (t1 : Type) (t2 : Type) : Bool =
   let s1 = show t1 in
   let s2 = show t2 in
   eval_bool {{ Util::lenPolyEq s1 s2 }};

/*
 * Check if a value of a value type is actually a valid value of
 * that type. In theory, we shouldn't ever attach types to invalid
 * values; we shouldn't ever construct any and potentially-garbage
 * values from outside should appear first as Values::Raw and get
 * checked before being converted to a specific value type.
 *
 * However, the Soroban SDK rust code plays fast and loose with
 * unsafe casts and we want to interoperate with it as much as
 * possible.
 *
 * The real type is:
 *    soroban_value_valid : (t : Type) -> t -> Bit
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_valid (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_valid }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_valid }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_valid }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_valid }}
   else if type_eq t {| Values::VecObjectT |} then
      {{ Values::vecobject_valid }}
   else if type_eq t {| Values::RawT |} then
      {{ Values::raw_valid }}
   else if type_eq t {| Store::T |} then
      // XXX: this gets passed here, but shouldn't be. ignore it for now
      // (this logic is for value types!)
      // XXX: this shouldn't happen any more, remove this case
      {{ \_ -> True }}
   else
      run (fail (str_concat (show t) " has no validity predicate"));

/*
 * Generate a fresh var of the requested value type.
 *
 * Note: only for value types.
 *
 * Note: we used to cons the name of the current spec onto the name
 * passed in. We don't do that any more because it requires all kinds
 * of contortions to remember the name in a useful way.
 */
let soroban_value_fresh (name : String) (t : Type) : MIRSetup Term = do {
   //let name' = str_concats [spec_name, "::", name];
   x <- mir_fresh_cryptol_var name t;
   let t_valid = soroban_value_valid t;
   mir_assert {{ t_valid x }};
   return x;
};

/*
 * Convert from a specific value type to Values::Raw::T.
 * Value types only.
 *
 * The real type is:
 *    soroban_value_to_raw : (t : Type) -> t -> Values::Raw::T
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_to_raw (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_to_raw }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_to_raw }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_to_raw }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_to_raw }}
   else if type_eq t {| Values::VecObjectT |} then
      {{ Values::vecobj_to_raw }}
   else
      run (fail (str_concat (show t) " cannot be converted to Raw"));

/*
 * Convert from a Values::Raw::T to a specific value type
 * (type is passed as the first argument)
 *
 * Returns None if the raw value is not actually a value
 * of the right type. Crashes if the type is wrong.
 *
 * The real type is:
 *    soroban_value_from_raw : (t : Type) -> Values::Raw::T -> Option::T t
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_from_raw (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_from_raw }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_from_raw }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_from_raw }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_from_raw }}
   else if type_eq t {| Values::VecObjectT |} then
      {{ Values::vecobj_from_raw }}
   else
      run (fail (str_concat (show t) " cannot be converted from Raw"));

/*
 * Extract the MIR-level type for type T. Value types only.
 *
 * This function is the type-level version of soroban_value_to_mir.
 */
let soroban_value_type_to_mir (smi : SorobanMIRItems) t =
   if type_eq t {| Values::VoidT |} then
      mir_adt (smi.VoidType ())
   else if type_eq t {| Values::BoolT |} then
      mir_adt (smi.BoolType ())
   else if type_eq t {| Values::U32T |} then
      mir_adt (smi.U32ValType ())
   else if type_eq t {| Values::SymbolT |} then
      mir_adt (smi.SymbolType ())
   else if type_eq t {| Values::VecObjectT |} then
      mir_adt (smi.VecObjectType ())
   else if type_eq t {| Values::RawT |} then
      mir_adt (smi.RawValType ())
   else
      run (fail (str_concat (show t) " cannot be converted to MIRType"));

/*
 * Convert a value of a value type (recall the value types are
 * Cryptol types and have Cryptol values) to a mir_term.
 *
 * The MIR term we want is the corresponding tree of constructors
 * from the Rust side. There are two ways to do this: we can
 * extract the semantic value from the Cryptol term (e.g. unit,
 * True, False, 131, "hello", or whatever), convert that to its
 * Rust/MIR form, then create calls to the corresponding chain of
 * Rust constructors. Or, we can take advantage of having modeled
 * the internal representation used on the Rust side to just
 * extract the internal representation and transfer that across.
 *
 * There are at least three reasons to prefer the latter:
 *    - the internal representation is a u64 and is therefore
 *      easily moved across;
 *    - we can construct calls to arbitrary Rust functions if
 *      needed, but using them in spec-level logic is at least
 *      problematic (not sure whether it's allowed at all);
 *    - when we get to supporting object-style values, the
 *      external pointer part can just be pushed across as part
 *      of the u64 and we don't need to process the referent.
 *
 * In fact, I think this is why the Cryptol-level value logic was
 * built to match the internals of the Rust value logic.
 *
 * Ergo, the way this works is:
 *    - for types that aren't Values::Raw::T, recurse on the raw
 *      value and pass the results to the corresponding Rust
 *      constructor;
 *    - for Values::Raw::T, extract the bits of the representation
 *      and pass that to the Rust constructor.
 *
 * Note that for the latter case we need to fetch the bits
 * directly rather than calling the Cryptol-level accessor
 * function. Otherwise SAW loses track of the value when doing
 * override matching and the specs we produce don't work. See
 * saw-script #2035.
 *
 * For reasons I don't understand this seems to apply only to
 * the raw layer; the accessor functions for the wrapper types
 * seem to work ok.
 */
rec soroban_value_to_mir (smi : SorobanMIRItems) x =
   let t = type x in
   if type_eq t {| Values::VoidT |} then
      mir_struct_value (smi.VoidType ()) [
         soroban_value_to_mir smi {{ Values::void_to_raw x }}
      ]
   else if type_eq t {| Values::BoolT |} then
      mir_struct_value (smi.BoolType ()) [
         soroban_value_to_mir smi {{ Values::bool_to_raw x }}
      ]
   else if type_eq t {| Values::U32T |} then
      mir_struct_value (smi.U32ValType ()) [
         soroban_value_to_mir smi {{ Values::u32_to_raw x }}
      ]
   else if type_eq t {| Values::SymbolT |} then
      mir_struct_value (smi.SymbolType ()) [
         smi.MaybeEnvVal (),
         mir_struct_value (smi.SymbolValType ()) [
            soroban_value_to_mir smi {{ Values::symbol_to_raw x }}
         ]
      ]
   else if type_eq t {| Values::VecObjectT |} then
      /*
       * We could convert to Vec<T> rather than VecObject the same way
       * symbols get converted to Symbol rather than SymbolVal. It is
       * the same kind of wrapper (it is just an Env and VecObject)...
       * but that requires handling T, and that creates all kinds of
       * complications because Rust's monomorphization pass happens
       * upstream of MIR where we're working.
       */
      mir_struct_value (smi.VecObjectType ()) [
         soroban_value_to_mir smi {{ Values::vecobject_to_raw x }}
      ]
   else if type_eq t {| Values::RawT |} then
      mir_struct_value (smi.RawValType ()) [
         // XXX: can't do this, it makes SAW unable to match specs
         //mir_term {{ Values::raw_get_payload x }}
         mir_term {{ x.bits }}
      ]
   else
      run (fail (str_concat (show t) " cannot be converted to a MIR value"));


////////////////////////////////////////////////////////////
// SDK value interface for host-stored objects

typedef SorobanHostHeapState = {
   ghoststate : Ghost
};

soroban_hostheap_state <- do {
   ghoststate <- declare_ghost_state "Soroban::hostheap";
   let state = {
      ghoststate = ghoststate
   };
   return state;
};

/* The state should be a Values::HostHeap */
let soroban_hostheap_assert_state (state : Term) : MIRSetup () = do {
   mir_ghost_value soroban_hostheap_state.ghoststate state;
};

let soroban_hostheap_get_state () : MIRSetup Term = do {
   /*
    * There isn't a get operation for SAWscript ghost variables (yet)
    * but allocating a fresh var and asserting equality to the
    * existing state is an adequate workaround.
    *
    * Note that it'll work even if what you need to do is extract the
    * state so as to run a custom equivalence test on it; this will
    * give a value bit-identical to the current state that you can
    * then do whatever other comparison on.
    */
   state <- mir_fresh_cryptol_var "Soroban::hostheap::get_state" {| Values::HostHeap |};
   soroban_hostheap_assert_state state;
   return state;
};

/* We can't do this; there's no mir_ghost_set_value yet */
//let soroban_hostheap_set_state (state : Term) : MIRSetup () = do {
//   mir_ghost_set_value soroban_hostheap_state.ghoststate state;
//};

/*
 * Given a function from hostheap state to hostheap state and
 * something, call it on the current state, update the state with the
 * results, and return the value.
 *
 * f can be thought of as a computation in the hostheap state monad
 * and this function does the computation to get the value out, given
 * that the state is ghost state kept in the SAWscript monad.
 *
 * (note though that we don't have anything as organized as an actual
 * monad definition, just state transformer functions, because the
 * type system tools aren't there)
 *
 * f's Cryptol type should be:
 *    Values::HostHeap -> (Values::HostHeap, t)
 *
 * ...can't do this until we get mir_ghost_set_value
 */
//let soroban_hostheap_run (f : Term) : MIRSetup Term = do {
//   state <- soroban_hostheap_get_state ();
//   let stateret = {{ f state }};
//   let state' = {{ stateret.0 }};
//   let ret = {{ stateret.1 }};
//   soroban_hostheap_set_state state';
//   return ret;
//};

/*
 * Specs for the SDK code.
 */

/*
 * Create a new vector. Takes one argument of type Values::Raw::T.
 * If it's Values::void, the length of the new vector is 0. Otherwise
 * it must be a U32Val that gives the length.
 *
 * Write separate specs for the void and u32 cases. This makes the
 * type wrangling easier.
 *
 * vec_new(env: Env, c: RawVal) : VecObject
 */
let vec_new_empty_spec (smi : SorobanMIRItems) = do {

   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a host heap
   heap <- mir_fresh_cryptol_var "values.vec_new/empty.heap" {| Values::HostHeap |};
   soroban_hostheap_assert_state heap;

   // call the function
   mir_execute_func [self, mir_term {{ Values::void }}];

   /*
    * The function allocates space on the external (host-side) heap
    * and returns a handle to it. Allocate a space in our model of the
    * host-side heap.
    *
    * Because we aren't verifying the host-side function, we can just
    * use the handle we get back from our model as the return value.
    * However, if we wanted to actually verify the host-side function,
    * that wouldn't be good enough; the handle value might not be the
    * same. Instead, we'd need to create a fresh u32 for the actual
    * return value and assert that it and our model handle both
    * point to the right vector data.
    *
    * Downstream of here anything that uses the handle should be
    * checking the value pointed to, not the handle value itself,
    * because (like a pointer) the actual handle value isn't
    * meaningful, and furthermore, you can have two different
    * handles for two copies of the same vector and they should
    * be treated as equal vector objects.
    *
    * (In principle we could make our heap model accurate enough that
    * the handle values would match up, since it's a table index and
    * not an actual pointer. But that doesn't address the comparison
    * concerns. For the moment the model isn't exact either -- on the
    * host side there are two object tables, not one, and the bottom
    * bit of the handle chooses between them. It isn't clear so far
    * what the difference between them is, but it doesn't appear to be
    * something we need to model to verify contracts.)
    */
   let heap'v = {{ Values::vecobj_empty heap }};
   let heap' = {{ heap'v.0 }};
   let v = {{ heap'v.1 }};

   // return the new object handle
   let mir_v = soroban_value_to_mir smi v;
   mir_return mir_v;
};
let vec_new_nonempty_spec (smi : SorobanMIRItems) = do {

   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a host heap
   heap <- mir_fresh_cryptol_var "values.vec_new/nonempty.heap" {| Values::HostHeap |};
   soroban_hostheap_assert_state heap;

   // get an argument
   n <- soroban_value_fresh "values.vec_new/nonempty.n" {| Values::U32T |};
   let native_n = {{ Values::u32_to_native n }};
   let mir_n = soroban_value_to_mir smi n;

   // call the function
   mir_execute_func [self, mir_n];

   // allocate in the model
   let heap'v = {{ Values::vecobj_n native_n heap }};
   let heap' = {{ heap'v.0 }};
   let v = {{ heap'v.1 }};

   // return the new object handle
   let mir_v = soroban_value_to_mir smi v;
   mir_return mir_v;
};

/*
 * Get the length of the vector v.
 *
 * vec_len(env: Env, v: VecObject) : U32Val
 */
let vec_len_spec (smi : SorobanMIRItems) = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get an argument
   v <- soroban_value_fresh "values.vec_len.v" {| Values::VecObjectT |};
   let mir_v = soroban_value_to_mir smi v;

   // get a host heap, which has a mapping for the VecObject
   heap <- mir_fresh_cryptol_var "values.vec_len.heap" {| Values::HostHeap |};
   mir_assert {{ Values::vecobj_exists v heap }};
   soroban_hostheap_assert_state heap;

   // get the length
   let native_len = {{ Values::vecobj_len v heap }};
   let len = {{ Values::u32_from_native native_len }};

   // call the function
   mir_execute_func [self, mir_v];

   // return the Values::U32::T length
   mir_return (mir_term len);
};

/*
 * Get index i of the vector v.
 *
 * i must be in bounds.
 *
 * vec_get(env: Env, v: VecObject, i: U32Val) : RawVal
 */
let vec_get_spec (smi : SorobanMIRItems) = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a vector argument
   v <- soroban_value_fresh "values.vec_get.v" {| Values::VecObjectT |};
   let mir_v = soroban_value_to_mir smi v;

   // get an index argument
   i <- soroban_value_fresh "values.vec_get.i" {| Values::U32T |};
   let native_i = {{ Values::u32_to_native i }};
   let mir_i = soroban_value_to_mir smi i;

   // get a host heap, which has a mapping for the VecObject
   heap <- mir_fresh_cryptol_var "values.vec_get.heap" {| Values::HostHeap |};
   mir_assert {{ Values::vecobj_exists v heap }};
   soroban_hostheap_assert_state heap;

   // get the length, check bounds requirement
   let native_len = {{ Values::vecobj_len v heap }};
   mir_assert {{ native_i < native_len }};

   // get the value
   let ret = {{ Values::vecobj_get v i heap }};
   let mir_ret = soroban_value_to_mir smi ret;

   // call the function
   mir_execute_func [self, mir_v, mir_i];

   // return the value
   mir_return (mir_term ret);
};

/*
 * Get index 0 of the vector v. Vector must not be empty.
 * Not sure why this is its own hypercall (vs. a wrapper around vec_get).
 *
 * vec_front(env: Env, v: VecObject) : RawVal
 */
//let vec_front_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Get index (len - 1) of the vector v. Vector must not be empty.
 *
 * vec_back(env: Env, v: VecObject) : RawVal
 */
//let vec_back_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Update index i of the vector v to value x. Returns the new
 * vector.
 *
 * i must be in bounds.
 *
 * vec_put(env: Env, v: VecObject, i: U32Val, x: RawVal) : VecObject
 */
//let vec_put_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Remove index i of the vector v. Returns the new smaller vector.
 *
 * i must be in bounds.
 *
 * vec_del(env: Env, v: VecObject, i: U32Val) : VecObject
 */
//let vec_del_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Inset at index i of the vector v. Returns the new larger vector.
 *
 * i must be in bounds.
 *
 * vec_ins(env: Env, v: VecObject, i: U32Val, x : RawVal) : VecObject
 */
//let vec_ins_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Insert value at the front. Returns the new larger vector.
 *
 * vec_push_front(env: Env, v: VecObject, x: RawVal) : VecObject
 */
//let vec_push_front_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Remove the value at the front. Vector must not be empty.
 *
 * Apparently equivalent to vec_del(v, 0), not sure why it's
 * its own hypercall.
 *
 * vec_pop_front(env: Env, v: VecObject) : RawVal)
 */
//let vec_pop_front_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Insert value at the end. Returns the new larger vector.
 *
 * vec_push_back(env: Env, v: VecObject, x: RawVal) : VecObject
 */
//let vec_push_back_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Remove the value at the end. Vector must not be empty.
 *
 * vec_pop_back(env: Env, v: VecObject) : RawVal
 */
//let vec_pop_back_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Concatenate two vecs. Total length must not overflow u32.
 * Returns the new vector.
 *
 * vec_append(env: Env, v1: VecObject, v2: VecObject) : VecObject
 */
//let vec_append_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Extract the range start-end as a new vector.
 * (Range appears to mean start through end - 1)
 * Indexes must be in bounds.
 *
 * vec_slice(env: Env, v: VecObject, start: U32Val, end: U32Val) : VecObject
 */
//let vec_slice_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Find the index of the first occurrence of x. Returns void if
 * there is none.
 *
 * vec_first_index_of(env: Env, v: VecObject, x: RawVal) : RawVal
 */
//let vec_first_index_of_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Find the index of the last occurrence of x. Returns void if
 * there is none.
 *
 * vec_last_index_of(env: Env, v: VecObject, x: RawVal) : RawVal
 */
//let vec_last_index_of_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Search for x. Returns two u32s in a u64. The lower one is
 * the vector index for the value. The upper one is either 1
 * (meaning the value in question is there) or 0 (meaning it's
 * not but that's where it would be / where to put it).
 *
 * Yes, it appears to return a Rust u64 and not a U64Val.
 *
 * vec_binary_search(env: Env, v: VecObject, x: RawVal) : u64
 */
//let vec_binary_search_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Create a new vector from the n RawVals at the given address a.
 *
 * vec_new_from_linear_memory(env: Env, a: U32Val, n: U32Val) : VecObject
 */
//let vec_new_from_linear_memory_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Get all the values from the vector into a buffer at the given
 * address a. Not sure what happens if n doesn't match the length.
 *
 * vec_unpack_to_linear_memory(env: Env, v: VecObject,
 *                             a: U32Val, n: U32Val) : Void
 */
//let vec_unpack_to_linear_memory_spec (smi : SorobanMIRItems) = do {
//};

/*
 * This is not a hypercall but we need to intercept it before it calls
 * vec_new_from_linear_memory, as in order to do that it does a
 * pointer -> u32 cast that crux-mir can't handle.
 *
 * vec_new_from_slice(env: Env, vals: &[RawVal]) ->
 *    Result<VecObject, Self::Error>
 *
 * For the moment at least we need a separate copy of this for each
 * distinct length, because arrays of symbolic length cause problems.
 */
let vec_new_from_slice_spec (n : Int) (smi : SorobanMIRItems) = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());
   // alternatively, get a Guest to override at a different point
   //self <- mir_alloc (mir_adt (smi.GuestType ()));
   //mir_points_to self (smi.GuestVal ());

   // get a length
   //n <- mir_fresh_cryptol_var "values.vec_new_from_slice.len" {| [32] |};

   // get a sequence of Values::Raw::T
   vals_contents_seq <- mir_fresh_cryptol_var "values.vec_new_from_slice.vals_contents" {| [n] Values::RawT |};

   // turn it into a SAW list and convert to MIR RawVals
   let mir_vals_contents_list = list.map (soroban_value_to_mir smi) (eval_list vals_contents_seq);

   // get the corresponding MIR array
   let RawVal = soroban_value_type_to_mir smi {| Values::RawT |};
   let mir_vals_contents_array = mir_array_value RawVal mir_vals_contents_list;

   // allocate and populate a reference to it
   vals <- mir_alloc (mir_array n RawVal);
   mir_points_to vals mir_vals_contents_array;

   // get a host heap model
   heap <- mir_fresh_cryptol_var "values.vec_new_from_slice.heap" {| Values::HostHeap |};
   soroban_hostheap_assert_state heap;

   // call the function, taking a slice reference to the array
   mir_execute_func [self, mir_slice_value vals];

   // allocate in the model
   let heap'v = {{ Values::vecobj_seq vals_contents_seq heap }};
   let heap' = {{ heap'v.0 }};
   let v = {{ heap'v.1 }};

   // return the new object handle
   // XXX share this logic with return_ok (which is currently below and
   // needs to be moved up)
   let rettype = soroban_value_type_to_mir smi (type v);
   let mir_v = soroban_value_to_mir smi v;
   let ok = mir_enum_value (smi.ResultInfallibleType rettype) "Ok" [mir_v];
   mir_return ok;
};


/*
 * Construct the "overrides" (checked or admitted SAW theorems, in
 * this case admitted) for the SDK host-stored-value interface.
 */
let make_hostvalue_overrides (smi : SorobanMIRItems) mod features = do {
   vec_new_overrides <- do {
      if string_list.elem "vec_new" features then do {
         vec_new_empty_spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_new"
            (vec_new_empty_spec smi);
         vec_new_nonempty_spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_new"
            (vec_new_nonempty_spec smi);
         return [vec_new_empty_spec, vec_new_nonempty_spec];
      }
      else
         return [];
   };
   vec_len_overrides <- do {
      if string_list.elem "vec_len" features then do {
         vec_len_spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_len"
            (vec_len_spec smi);
         return [vec_len_spec];
      }
      else
         return [];
   };
   vec_get_overrides <- do {
      if string_list.elem "vec_get" features then do {
         vec_get_spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_get"
            (vec_get_spec smi);
         return [vec_get_spec];
      }
      else
         return [];
   };
   vec_new_from_slice_overrides <- do {
      if string_list.elem "vec_new_from_slice" features then do {
         let make n = do {
            spec <- mir_unsafe_assume_spec mod
               // either of these is a possible interception point
               // (the first just calls the second)
               "soroban_sdk::env::{impl#9}::vec_new_from_slice"
               //"soroban_env_guest::guest::{impl#0}::vec_new_from_slice"
               (vec_new_from_slice_spec n smi);
            return spec;
         };
         spec_0 <- make 0;
         spec_1 <- make 1;
         spec_2 <- make 2;
         spec_3 <- make 3;
         spec_4 <- make 4;
         spec_5 <- make 5;
         return [spec_0, spec_1, spec_2, spec_3, spec_4, spec_5];
      }
      else
         return [];
   };
   return (list.concats [
      vec_new_overrides,
      vec_len_overrides,
      vec_get_overrides,
      vec_new_from_slice_overrides
   ]);
};


////////////////////////////////////////////////////////////
// SDK storage interface

/*
 * Spec for the storage interface.
 *
 * To (maybe) improve clarity we refer to the moving parts of the
 * storage interface as follows:
 *    - "storage" is the name of the overall interface and concept
 *    - "store" is the name of the data structure we use to model the contents
 *
 * There are three parts to the code:
 *    - a Cryptol implementation of the store
 *    - a SAW wrapper around the Cryptol
 *    - SAW specs for the Rust interface
 *
 * Note that currently the model version of the code (the Cryptol and
 * the SAW wrapper) requires that contract specs explicitly update the
 * storage state after manipulating the store, but the Rust interface
 * specs (necessarily) do this internally. This is on the one hand
 * similar, but it also means that contract specs have to do extra
 * work/operations that have no equivalent in their Rust code and I'm
 * not sure that's a good way to do things. That is, I'm suggesting
 * that the SAW store ops below that just manipulate store values
 * should be extended to storage ops that update the state and thus
 * apply to the whole storage model. This wants some thought.
 *
 * For now at least the Cryptol-level store is written purely in terms
 * of Values::Raw::T and the type wrapping happens here. It's possible
 * that should change, but we'll see.
 */

/*
 * The model of the storage contents. Because the ghost state we keep
 * it in is mutable, it doesn't need to be passed around and can live
 * as a global here. Wrap it in a type to help prevent accidents.
 */
typedef SorobanStorageState = {
   ghoststate : Ghost
};

soroban_storage_state <- do {
   ghoststate <- declare_ghost_state "Soroban::storage";
   let state = {
      ghoststate = ghoststate
   };
   return state;
};

/*
 * Assert that the internally tracked model of the storage contents
 * matches another Store.
 */
let soroban_storage_assert_state (store : Term /* Store */) : MIRSetup () = do {
   mir_ghost_value soroban_storage_state.ghoststate store;
};

/*
 * Ops on store values. These are basically type wrappers around
 * the Cryptol version of the Store.
 */

/*
 * Check if the a store has a given key. The key can be any value
 * type. Returns a Cryptol Bool.
 */
let soroban_store_has (store : Term /* Store */) (k : Term) =
   let k_to_raw = soroban_value_to_raw (type k) in
   {{ Store::has store (k_to_raw k) }};

/*
 * Get the contents in a store under a given key, as type tv.
 * The key can be any value type.
 *
 * Returns a Term with Cryptol type Option::T (Option::T tv).
 * If the outer Option is None, there was no such key in the store.
 * If the inner Option is None, the value found was not the expected type.
 *
 * (This is apparently the same interface as the SDK Rust code.)
 */
let soroban_store_get (store : Term /* Store */) (k : Term) (tv : Type) =
   let k_to_raw = soroban_value_to_raw (type k) in
   let v_from_raw = soroban_value_from_raw tv in
   {{ Option::fmap (Store::get store (k_to_raw k)) v_from_raw }};

/*
 * Set the contents in a store under a given key. The key and value
 * can be any value type.
 *
 * Returns a new Cryptol Store value.
 */
let soroban_store_set (store : Term /* Store */) (k : Term) (v : Term) =
   let k_to_raw = soroban_value_to_raw (type k) in
   let v_to_raw = soroban_value_to_raw (type v) in
   {{ Store::set store (k_to_raw k) (v_to_raw v) }};

/*
 * Specs for the SDK code.
 */

/*
 * Helper for returning Ok from a Rust function.
 */
let return_ok (smi : SorobanMIRItems) (x : Term) : MIRSetup () =
   mir_return
      (mir_enum_value
         (smi.ResultInfallibleType (soroban_value_type_to_mir smi (type x)))
         "Ok"
         [soroban_value_to_mir smi x]);

/*
 * Spec for has_contract_data()
 */
let storage_has_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.has.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.has.k" {| Values::RawT |};
   // XXX: should assert that k has a valid type tag

   soroban_storage_assert_state store;

   mir_execute_func [self, soroban_value_to_mir smi k];

   soroban_storage_assert_state store;

   return_ok smi {{ Values::bool_from_native (Store::has store k) }};
};

/*
 * Spec for get_contract_data()
 */
let storage_get_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.get.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.get.k" {| Values::RawT |};
   // XXX: should assert that k has a valid type tag

   // XXX is it really wrong to call get without first calling has?
   // seems unusual, and also inconsistent with the return type of
   // get.
   mir_precond {{ Store::has store k }};
   soroban_storage_assert_state store;

   mir_execute_func [self, soroban_value_to_mir smi k];

   soroban_storage_assert_state store;

   // XXX probably relatedly, this doesn't seem to be able to
   // return failure. But, this seems like it will do the wrong
   // thing if the type in the store is wrong...
   return_ok smi {{ (Store::get store k).value }};
};

/*
 * Spec for put_contract_data
 *
 * XXX: why are we calling our internal things "set" when the SDK uses "put"?
 */
let storage_put_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.put.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.put.k" {| Values::RawT |};
   v <- soroban_value_fresh "storage.put.v" {| Values::RawT |};
   // XXX: should assert that k and v have valid type tags

   soroban_storage_assert_state store;

   let k_val = soroban_value_to_mir smi k;
   let v_val = soroban_value_to_mir smi v;
   mir_execute_func [self, k_val, v_val];

   soroban_storage_assert_state {{ Store::set store k v }};

   // Return the SDK void value.
   return_ok smi {{ Values::unit }};
};

/*
 * Construct the "overrides" (checked or admitted SAW theorems, in
 * this case admitted) for the SDK storage interface.
 */
let make_storage_overrides (smi : SorobanMIRItems) mod features = do {
   if string_list.elem "storage" features then do {
      has_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::has_contract_data"
         (storage_has_spec smi);
      get_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::get_contract_data"
         (storage_get_spec smi);
      put_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::put_contract_data"
         (storage_put_spec smi);
      return [has_spec, get_spec, put_spec];
   }
   else
      return [];
};


////////////////////////////////////////////////////////////
// SDK logging interface

/*
 * Spec for the logging interface.
 *
 * Similarly to the storage interface, we name things as follows:
 *    - "logging" is the name of the over all interface and concept
 *    - "log" is the name of the data structure we use to model the contents
 *
 * There are three parts to this code:
 *    - a Cryptol model of the log
 *    - ghost state and glue for handling the model in SAW
 *    - SAW specs for the Rust interface
 *
 * For the time being we model the log just by counting the number of
 * messages logged.
 */

typedef SorobanLoggingState = {
   ghoststate : Ghost
};

soroban_logging_state <- do {
   ghoststate <- declare_ghost_state "Soroban::logging";
   let state = {
      ghoststate = ghoststate
   };
   return state;
};

/*
 * Assert equality of the internally tracked model of the log contents
 * with a new Log.
 */
let soroban_logging_assert_state (log : Term /* Log */) : MIRSetup () = do {
   mir_ghost_value soroban_logging_state.ghoststate log;
};

/*
 * We don't need to provide SAW-level ops on logs because the
 * Cryptol-level ops are sufficient.
 */

/*
 * Specs for the SDK code.
 *
 * Wrinkle: the main interface is a macro log! that takes an
 * environment and arbitrarily many arguments and converts that to a
 * call to Logs::add that takes the first string and then arbitrarily
 * many more raw values.
 *
 * Also note that while there's two more calls "all" and "print" on
 * that type, they're only available in test mode, which we don't
 * handle. So for present purposes the log is write-only.
 *
 * Note: in the version of the SDK we're using, logs::Logs::add is called
 * logging::Logger::log
 */

let logging_add_spec (smi : SorobanMIRItems) = do {
   // get a fresh log and bind it to the log state
   log <- mir_fresh_cryptol_var "logging.add.log" {| Log::T |};
   soroban_logging_assert_state log;

   // get a fresh environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a fresh string
   str <- mir_alloc mir_str;

   // get a fresh args (which is actually a reference to an array)
   // XXX it appears to be an array of any length? for now use a length
   // of 1
   // XXX: should also assert that each raw value in the array has
   // a valid type tag
   let tyargs = mir_array 1 (mir_adt (smi.RawValType ()));
   args_val <- mir_fresh_var "args_val" tyargs;
   args <- mir_alloc tyargs;
   mir_points_to args (mir_term args_val);

   mir_execute_func [self, str, args];

   // compute the proper updated log state
   let log' = {{ Log::add log }};

   // assert the updated log state
   soroban_logging_assert_state log';
};

/*
 * Construct the "overrides" (checked or admitted SAW theorems, in
 * this case admitted) for the SDK storage interface.
 */
let make_logging_overrides (smi : SorobanMIRItems) mod features = do {
   if string_list.elem "logging" features then do {
      add_spec <- mir_unsafe_assume_spec mod
         //"soroban_sdk::logs::{impl#1}::add"
         "soroban_sdk::logging::{impl#1}::log"
         (logging_add_spec smi);
      return [add_spec];
   }
   else
      return [];
};


////////////////////////////////////////////////////////////
// verify

/*
 * Args passed to verify
 */
typedef SorobanVerifyArgs = {
  fun : String,
  overrides : [MIRSpec],
  path_sat : Bool,
  spec : MIRSetup (),
  proof : ProofScript ()
};

/*
 * Hook for running verification
 */
let soroban_verify (soroban : SorobanAPI) (args : SorobanVerifyArgs) =
   mir_verify soroban.mod args.fun (concat soroban.sdk_overrides args.overrides)
        args.path_sat args.spec args.proof;

/*
 * Hook for assuming a specification instead
 * (intentionally has the same signature, even though some of it
 * isn't used)
 */
let soroban_assume (soroban : SorobanAPI) (args : SorobanVerifyArgs) =
   mir_unsafe_assume_spec soroban.mod args.fun args.spec;


////////////////////////////////////////////////////////////
// init

/*
 * Function to initialize the stuff in here.
 *
 * mod is the results of mir_load_module on the linked_mir.json file
 * containing the stuff we're trying to verify.
 *
 * The features list is a list of arbitrary strings naming things the
 * rust code is using; it prevents us from looking for MIR symbols
 * that don't exist. FUTURE: it should be a list of an enum type...
 */
let soroban_init (mod : MIRModule) (features : [String]) : TopLevel SorobanAPI = do {

   let feat_implies feats (x, y) =
      if string_list.elem x feats then concat [y] feats else feats;

   let features = list.foldl feat_implies features [
      ("storage", "bool_val"),
      ("storage", "void_val"),
      ("symbol", "maybe_env")
   ];

   let smi = make_soroban_mir_items mod features;

   storage_overrides <- make_storage_overrides smi mod features;
   hostvalue_overrides <- make_hostvalue_overrides smi mod features;

   // note: "concat" is what's usually called append
   let sdk_overrides = concat hostvalue_overrides storage_overrides;

   return {
      mod = mod,
      smi = smi,
      sdk_overrides = sdk_overrides
   };
};
