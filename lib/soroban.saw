enable_experimental;

include "list.saw";

/*
 * Load the cryptol modules.
 */

Util <- cryptol_load "Util.cry";
Option <- cryptol_load "Option.cry";
Values <- cryptol_load "Values.cry";
Store <- cryptol_load "Store.cry";
Log <- cryptol_load "Log.cry";
EventLog <- cryptol_load "EventLog.cry";


////////////////////////////////////////////////////////////
// MIR symbols

/*
 * Symbols extracted from the MIR
 */
typedef SorobanMIRItems = {
   // non-soroban
   InfallibleType : (() -> MIRAdt),
   ResultInfallibleType : (MIRType -> MIRAdt),

   // from the soroban_env_guest crate
   GuestType : (() -> MIRAdt),
   GuestVal : (() -> MIRValue),

   // from the soroban_sdk crate
   EnvType : (() -> MIRAdt),
   EnvVal : (() -> MIRValue),
   MaybeEnvType : (() -> MIRAdt),
   MaybeEnvVal : (() -> MIRValue),
   StorageType : (() -> MIRAdt),
   StorageVal : (() -> MIRValue),
   EventsType : (() -> MIRAdt),
   EventsVal : (() -> MIRValue),
   SymbolType : (() -> MIRAdt),

   // from the soroban_env_common crate
   VoidType : (() -> MIRAdt),
   BoolType : (() -> MIRAdt),
   U32ValType : (() -> MIRAdt),
   StringObjectType : (() -> MIRAdt),
   SymbolValType : (() -> MIRAdt),
   VecObjectType : (() -> MIRAdt),
   MapObjectType : (() -> MIRAdt),
   RawValType : (() -> MIRAdt)
};

let make_soroban_mir_items mod features : SorobanMIRItems =
   /*
    * Tools for looking up stuff in the MIR.
    */
   let find_adt adt_name =
     let adt = mir_find_adt mod adt_name [] in
     \() -> adt
   in
   let find_adt_when feat adt_name =
     if string_list.elem feat features then
       find_adt adt_name
     else
       \() -> run (fail (str_concats [
         "Feature \"", feat, "\" is required for type ", adt_name
       ]))
   in

   /*
    * Bind handles for various SDK types and values.
    *
    * These bindings are delayed so we don't crash looking for
    * things that might not exist in the test MIR until something
    * explicitly asks for them.
    *
    * XXX: seems like we don't need both the delay behavior and
    * the features list. Simplify?
    *
    * XXX: also, while maybe there's some virtue to looking up types
    * in advance (so they only get looked up once each) I'm not sure
    * there's anything to be gained by having value construction
    * functions here vs. just calling them as needed.
    */

   // non-soroban
   let InfallibleType = find_adt "core::convert::Infallible" in
   let ResultInfallibleType (t : MIRType) =
      mir_find_adt mod "core::result::Result" [t, mir_adt (InfallibleType ())]
   in

   // from the soroban_env_guest crate
   let GuestType = find_adt "soroban_env_guest::guest::Guest" in
   let GuestVal () = mir_struct_value (GuestType ()) [] in

   // from the soroban_sdk crate
   let EnvType = find_adt "soroban_sdk::env::Env" in
   let EnvVal () = mir_struct_value (EnvType ()) [GuestVal ()] in
   let MaybeEnvType = find_adt_when "maybe_env" "soroban_sdk::env::MaybeEnv" in
   let MaybeEnvVal () = mir_struct_value (MaybeEnvType ()) [GuestVal ()] in
   let StorageType = find_adt_when "storage" "soroban_sdk::storage::Storage" in
   let StorageVal () = mir_struct_value (StorageType ()) [EnvVal ()] in
   let EventsType = find_adt_when "events" "soroban_sdk::events::Events" in
   let EventsVal () = mir_struct_value (EventsType ()) [EnvVal ()] in
   let SymbolType = find_adt_when "symbol" "soroban_sdk::symbol::Symbol" in

   // from the soroban_env_common crate
   let VoidType = find_adt_when "void_val" "soroban_env_common::raw_val::Void" in
   let BoolType = find_adt_when "bool_val" "soroban_env_common::raw_val::Bool" in
   let U32ValType = find_adt_when "u32_val" "soroban_env_common::num::U32Val" in
   let StringObjectType = find_adt_when "str_val" "soroban_env_common::string::StringObject" in
   let SymbolValType = find_adt_when "symbol" "soroban_env_common::symbol::Symbol" in
   let VecObjectType = find_adt_when "vec_val" "soroban_env_common::raw_val::VecObject" in
   let MapObjectType = find_adt_when "map_val" "soroban_env_common::raw_val::MapObject" in
   let RawValType = find_adt "soroban_env_common::raw_val::RawVal" in

   {
      InfallibleType = InfallibleType,
      ResultInfallibleType = ResultInfallibleType,

      // from the soroban_env_guest crate
      GuestType = GuestType,
      GuestVal = GuestVal,

      // from the soroban_sdk crate
      EnvType = EnvType,
      EnvVal = EnvVal,
      MaybeEnvType = MaybeEnvType,
      MaybeEnvVal = MaybeEnvVal,
      StorageType = StorageType,
      StorageVal = StorageVal,
      EventsType = EventsType,
      EventsVal = EventsVal,
      SymbolType = SymbolType,

      // from the soroban_env_common crate
      VoidType = VoidType,
      BoolType = BoolType,
      U32ValType = U32ValType,
      StringObjectType = StringObjectType,
      SymbolValType = SymbolValType,
      VecObjectType = VecObjectType,
      MapObjectType = MapObjectType,
      RawValType = RawValType
   };


////////////////////////////////////////////////////////////
// Top-level context

/*
 * Material returned by the init function for use by the actual specs:
 *    - the MIR module
 *    - references to MIR symbols from the SDK
 *    - overrides list for functions from the SDK
 */
typedef SorobanAPI = {
   mod : MIRModule,
   smi : SorobanMIRItems,
   sdk_overrides : [MIRSpec]
};


////////////////////////////////////////////////////////////
// SDK value interface

/*
 * Hook for dynamic type dispatch on the value types.
 *
 * This should really be module-private if there were such a thing.
 */
let type_eq (t1 : Type) (t2 : Type) : Bool =
   let s1 = show t1 in
   let s2 = show t2 in
   eval_bool {{ Util::lenPolyEq s1 s2 }};

/*
 * Check if a value of a value type is actually a valid value of
 * that type. In theory, we shouldn't ever attach types to invalid
 * values; we shouldn't ever construct any and potentially-garbage
 * values from outside should appear first as Values::Raw and get
 * checked before being converted to a specific value type.
 *
 * However, the Soroban SDK rust code plays fast and loose with
 * unsafe casts and we want to interoperate with it as much as
 * possible.
 *
 * The real type is:
 *    soroban_value_valid : (t : Type) -> t -> Bit
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_valid (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_valid }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_valid }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_valid }}
   else if type_eq t {| Values::StringObjectT |} then
      {{ Values::strobj_valid }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_valid }}
   else if type_eq t {| Values::VecObjectT |} then
      {{ Values::vecobject_valid }}
   else if type_eq t {| Values::MapObjectT |} then
      {{ Values::mapobj_valid }}
   else if type_eq t {| Values::RawT |} then
      {{ Values::raw_valid }}
   else if type_eq t {| Store::T |} then
      // XXX: this gets passed here, but shouldn't be. ignore it for now
      // (this logic is for value types!)
      // XXX: this shouldn't happen any more, remove this case
      {{ \_ -> True }}
   else
      run (fail (str_concat (show t) " has no validity predicate"));

/*
 * Generate a fresh var of the requested value type.
 *
 * Note: only for value types.
 *
 * Note: we used to cons the name of the current spec onto the name
 * passed in. We don't do that any more because it requires all kinds
 * of contortions to remember the name in a useful way.
 */
let soroban_value_fresh (name : String) (t : Type) : MIRSetup Term = do {
   //let name' = str_concats [spec_name, "::", name];
   x <- mir_fresh_cryptol_var name t;
   let t_valid = soroban_value_valid t;
   mir_assert {{ t_valid x }};
   return x;
};

/*
 * Generate a fresh raw value.
 */
let soroban_raw_fresh (name : String) = do {
   v <- soroban_value_fresh name {| Values::RawT |};
   return v;
};

/*
 * Generate a sequence of n fresh RawVals.
 * (For n > 0, the empty case isn't interesting.)
 *
 * The sequence itself is not (must not be) fresh.
 */
let soroban_raw1_fresh basename : MIRSetup Term = do {
   val0 <- soroban_raw_fresh (str_concat basename ".val0");
   return {{ [val0] }};
};
let soroban_raw2_fresh basename : MIRSetup Term = do {
   val0 <- soroban_raw_fresh (str_concat basename ".val0");
   val1 <- soroban_raw_fresh (str_concat basename ".val1");
   return {{ [val0, val1] }};
};
let soroban_raw3_fresh basename : MIRSetup Term = do {
   val0 <- soroban_raw_fresh (str_concat basename ".val0");
   val1 <- soroban_raw_fresh (str_concat basename ".val1");
   val2 <- soroban_raw_fresh (str_concat basename ".val2");
   return {{ [val0, val1, val2] }};
};
let soroban_raw4_fresh basename : MIRSetup Term = do {
   val0 <- soroban_raw_fresh (str_concat basename ".val0");
   val1 <- soroban_raw_fresh (str_concat basename ".val1");
   val2 <- soroban_raw_fresh (str_concat basename ".val2");
   val3 <- soroban_raw_fresh (str_concat basename ".val3");
   return {{ [val0, val1, val2, val3] }};
};
let soroban_raw5_fresh basename : MIRSetup Term = do {
   val0 <- soroban_raw_fresh (str_concat basename ".val0");
   val1 <- soroban_raw_fresh (str_concat basename ".val1");
   val2 <- soroban_raw_fresh (str_concat basename ".val2");
   val3 <- soroban_raw_fresh (str_concat basename ".val3");
   val4 <- soroban_raw_fresh (str_concat basename ".val4");
   return {{ [val0, val1, val2, val3, val4] }};
};

/*
 * Generate a sequence of n fresh strings of length m.
 * (For n > 0, the empty case isn't interesting.)
 *
 * The sequence itself is not (must not be) fresh.
 */
let soroban_string1_fresh m basename : MIRSetup Term = do {
   val0 <- mir_fresh_cryptol_var (str_concat basename ".val0") {| String m |};
   return {{ [val0] }};
};
let soroban_string2_fresh m basename : MIRSetup Term = do {
   val0 <- mir_fresh_cryptol_var (str_concat basename ".val0") {| String m |};
   val1 <- mir_fresh_cryptol_var (str_concat basename ".val1") {| String m |};
   return {{ [val0, val1] }};
};
let soroban_string3_fresh m basename : MIRSetup Term = do {
   val0 <- mir_fresh_cryptol_var (str_concat basename ".val0") {| String m |};
   val1 <- mir_fresh_cryptol_var (str_concat basename ".val1") {| String m |};
   val2 <- mir_fresh_cryptol_var (str_concat basename ".val2") {| String m |};
   return {{ [val0, val1, val2] }};
};
let soroban_string4_fresh m basename : MIRSetup Term = do {
   val0 <- mir_fresh_cryptol_var (str_concat basename ".val0") {| String m |};
   val1 <- mir_fresh_cryptol_var (str_concat basename ".val1") {| String m |};
   val2 <- mir_fresh_cryptol_var (str_concat basename ".val2") {| String m |};
   val3 <- mir_fresh_cryptol_var (str_concat basename ".val3") {| String m |};
   return {{ [val0, val1, val2, val3] }};
};
let soroban_string5_fresh m basename : MIRSetup Term = do {
   val0 <- mir_fresh_cryptol_var (str_concat basename ".val0") {| String m |};
   val1 <- mir_fresh_cryptol_var (str_concat basename ".val1") {| String m |};
   val2 <- mir_fresh_cryptol_var (str_concat basename ".val2") {| String m |};
   val3 <- mir_fresh_cryptol_var (str_concat basename ".val3") {| String m |};
   val4 <- mir_fresh_cryptol_var (str_concat basename ".val4") {| String m |};
   return {{ [val0, val1, val2, val3, val4] }};
};

/*
 * Convert from a specific value type to Values::Raw::T.
 * Value types only.
 *
 * The real type is:
 *    soroban_value_to_raw : (t : Type) -> t -> Values::Raw::T
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_to_raw (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_to_raw }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_to_raw }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_to_raw }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_to_raw }}
   else if type_eq t {| Values::VecObjectT |} then
      {{ Values::vecobject_to_raw }}
   else if type_eq t {| Values::MapObjectT |} then
      {{ Values::mapobj_to_raw }}
   else
      run (fail (str_concat (show t) " cannot be converted to Raw"));

/*
 * Convert from a Values::Raw::T to a specific value type
 * (type is passed as the first argument)
 *
 * Returns None if the raw value is not actually a value
 * of the right type. Crashes if the type is invalid/inappropriate.
 *
 * The real type is:
 *    soroban_value_from_raw : (t : Type) -> Values::Raw::T -> Option::T t
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_from_raw (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_from_raw }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_from_raw }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_from_raw }}
   else if type_eq t {| Values::StringObjectT |} then
      {{ Values::strobj_from_raw }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_from_raw }}
   else if type_eq t {| Values::VecObjectT |} then
      {{ Values::vecobject_from_raw }}
   else if type_eq t {| Values::MapObjectT |} then
      {{ Values::mapobj_from_raw }}
   else
      run (fail (str_concat (show t) " cannot be converted from Raw"));

/*
 * Extract the MIR-level type for type T. Value types only.
 *
 * This function is the type-level version of soroban_value_to_mir.
 */
let soroban_value_type_to_mir (smi : SorobanMIRItems) t =
   if type_eq t {| Values::VoidT |} then
      mir_adt (smi.VoidType ())
   else if type_eq t {| Values::BoolT |} then
      mir_adt (smi.BoolType ())
   else if type_eq t {| Values::U32T |} then
      mir_adt (smi.U32ValType ())
   else if type_eq t {| Values::StringObjectT |} then
      mir_adt (smi.StringObjectType ())
   else if type_eq t {| Values::SymbolT |} then
      mir_adt (smi.SymbolType ())
   else if type_eq t {| Values::VecObjectT |} then
      mir_adt (smi.VecObjectType ())
   else if type_eq t {| Values::MapObjectT |} then
      mir_adt (smi.MapObjectType ())
   else if type_eq t {| Values::RawT |} then
      mir_adt (smi.RawValType ())
   else
      run (fail (str_concat (show t) " cannot be converted to MIRType"));

/*
 * Convert a value of a value type (recall the value types are
 * Cryptol types and have Cryptol values) to a mir_term.
 *
 * The MIR term we want is the corresponding tree of constructors
 * from the Rust side. There are two ways to do this: we can
 * extract the semantic value from the Cryptol term (e.g. unit,
 * True, False, 131, "hello", or whatever), convert that to its
 * Rust/MIR form, then create calls to the corresponding chain of
 * Rust constructors. Or, we can take advantage of having modeled
 * the internal representation used on the Rust side to just
 * extract the internal representation and transfer that across.
 *
 * There are at least three reasons to prefer the latter:
 *    - the internal representation is a u64 and is therefore
 *      easily moved across;
 *    - we can construct calls to arbitrary Rust functions if
 *      needed, but using them in spec-level logic is at least
 *      problematic (not sure whether it's allowed at all);
 *    - for object-style values, the external pointer part can just be
 *      pushed across as part of the u64 and we don't need to process
 *      the referent.
 *
 * In fact, I think this is why the Cryptol-level value logic was
 * built to match the internals of the Rust value logic.
 *
 * Ergo, the way this works is:
 *    - for types that aren't Values::Raw::T, recurse on the raw
 *      value and pass the results to the corresponding Rust
 *      constructor;
 *    - for Values::Raw::T, extract the bits of the representation
 *      and pass that to the Rust constructor.
 *
 * Note that we need to fetch the contents out directly rather than
 * calling the Cryptol-level accessor function. Otherwise SAW loses
 * track of the value when doing override matching and the specs we
 * produce don't work. See saw-script #2035. XXX: this is ugly.
 */
rec soroban_value_to_mir (smi : SorobanMIRItems) x =
   let t = type x in
   if type_eq t {| Values::VoidT |} then
      mir_struct_value (smi.VoidType ()) [
         //soroban_value_to_mir smi {{ Values::void_to_raw x }}
         soroban_value_to_mir smi {{ x.val }}
      ]
   else if type_eq t {| Values::BoolT |} then
      mir_struct_value (smi.BoolType ()) [
         //soroban_value_to_mir smi {{ Values::bool_to_raw x }}
         soroban_value_to_mir smi {{ x.val }}
      ]
   else if type_eq t {| Values::U32T |} then
      mir_struct_value (smi.U32ValType ()) [
         //soroban_value_to_mir smi {{ Values::u32_to_raw x }}
         soroban_value_to_mir smi {{ x.val }}
      ]
   else if type_eq t {| Values::StringObjectT |} then
      mir_struct_value (smi.StringObjectType ()) [
         //soroban_value_to_mir smi {{ Values::strobj_to_raw x }}
         soroban_value_to_mir smi {{ x.val }}
      ]
   else if type_eq t {| Values::SymbolT |} then
      mir_struct_value (smi.SymbolType ()) [
         smi.MaybeEnvVal (),
         mir_struct_value (smi.SymbolValType ()) [
            //soroban_value_to_mir smi {{ Values::symbol_to_raw x }}
            soroban_value_to_mir smi {{ x.val }}
         ]
      ]
   else if type_eq t {| Values::VecObjectT |} then
      /*
       * We could convert to Vec<T> rather than VecObject the same way
       * symbols get converted to Symbol rather than SymbolVal. It is
       * the same kind of wrapper (it is just an Env and VecObject)...
       * but that requires handling T, and that creates all kinds of
       * complications because Rust's monomorphization pass happens
       * upstream of MIR where we're working.
       */
      mir_struct_value (smi.VecObjectType ()) [
         //soroban_value_to_mir smi {{ Values::vecobject_to_raw x }}
         soroban_value_to_mir smi {{ x.val }}
      ]
   else if type_eq t {| Values::MapObjectT |} then
      mir_struct_value (smi.MapObjectType ()) [
         //soroban_value_to_mir smi {{ Values::mapobj_to_raw x }}
         soroban_value_to_mir smi {{ x.val }}
      ]
   else if type_eq t {| Values::RawT |} then
      mir_struct_value (smi.RawValType ()) [
         //mir_term {{ Values::raw_get_payload x }}
         mir_term {{ x.bits }}
      ]
   else
      run (fail (str_concat (show t) " cannot be converted to a MIR value"));


////////////////////////////////////////////////////////////
// SDK value interface for host-stored objects

/*
 * This is the heap state used by the hypercall-level override specs
 * found immediately below. Specs for contract code (and any specs for
 * higher-level parts of the SDK) should not touch this state directly
 * but maintain their own model and assert equivalence between that
 * model and this one before and after mir_execute_func.
 */
typedef SorobanHostHeapState = {
   ghoststate : Ghost
};

soroban_hostheap_state <- do {
   ghoststate <- declare_ghost_state "Soroban::hostheap";
   let state = {
      ghoststate = ghoststate
   };
   return state;
};

/* The state should be a Values::HostHeap */
let soroban_hostheap_assert_state (state : Term) : MIRSetup () = do {
   mir_ghost_value soroban_hostheap_state.ghoststate state;
};

let soroban_hostheap_get_state () : MIRSetup Term = do {
   /*
    * There isn't a get operation for SAWscript ghost variables (yet)
    * but allocating a fresh var and asserting equality to the
    * existing state is an adequate workaround.
    *
    * Note that it'll work even if what you need to do is extract the
    * state so as to run a custom equivalence test on it; this will
    * give a value bit-identical to the current state that you can
    * then do whatever other comparison on.
    */
   state <- mir_fresh_cryptol_var "Soroban::hostheap::get_state" {| Values::HostHeap |};
   soroban_hostheap_assert_state state;
   return state;
};

/* We can't do this; there's no mir_ghost_set_value yet */
//let soroban_hostheap_set_state (state : Term) : MIRSetup () = do {
//   mir_ghost_set_value soroban_hostheap_state.ghoststate state;
//};

/*
 * Given a function from hostheap state to hostheap state and
 * something, call it on the current state, update the state with the
 * results, and return the value.
 *
 * f can be thought of as a computation in the hostheap state monad
 * and this function does the computation to get the value out, given
 * that the state is ghost state kept in the SAWscript monad.
 *
 * (note though that we don't have anything as organized as an actual
 * monad definition, just state transformer functions, because the
 * type system tools aren't there)
 *
 * f's Cryptol type should be:
 *    Values::HostHeap -> (Values::HostHeap, t)
 *
 * ...can't do this until we get mir_ghost_set_value
 */
//let soroban_hostheap_run (f : Term) : MIRSetup Term = do {
//   state <- soroban_hostheap_get_state ();
//   let stateret = {{ f state }};
//   let state' = {{ stateret.0 }};
//   let ret = {{ stateret.1 }};
//   soroban_hostheap_set_state state';
//   return ret;
//};

/*
 * Helpers for contract specs.
 */

/* allocating constructors */

let soroban_value_vecobj_0 heap = do {
   return {{ Values::vecobj_empty heap }};
};

let soroban_value_vecobj_1 val heap = do {
   let val_to_raw = soroban_value_to_raw (type val);
   let val_raw = {{ val_to_raw val }};
   return {{ Values::vecobj_singleton val_raw heap }};
};

let soroban_value_vecobj_2 val1 val2 heap = do {
   let val1_to_raw = soroban_value_to_raw (type val1);
   let val2_to_raw = soroban_value_to_raw (type val2);
   let val1_raw = {{ val1_to_raw val1 }};
   let val2_raw = {{ val2_to_raw val2 }};
   return {{ Values::vecobj_pair val1_raw val2_raw heap }};
};

let soroban_value_vecobj_3 val1 val2 val3 heap = do {
   let val1_to_raw = soroban_value_to_raw (type val1);
   let val2_to_raw = soroban_value_to_raw (type val2);
   let val3_to_raw = soroban_value_to_raw (type val3);
   let val1_raw = {{ val1_to_raw val1 }};
   let val2_raw = {{ val2_to_raw val2 }};
   let val3_raw = {{ val3_to_raw val3 }};
   return {{ Values::vecobj_triple val1_raw val2_raw val3_raw heap }};
};

let soroban_value_vecobj_4 val1 val2 val3 val4 heap = do {
   let val1_to_raw = soroban_value_to_raw (type val1);
   let val2_to_raw = soroban_value_to_raw (type val2);
   let val3_to_raw = soroban_value_to_raw (type val3);
   let val4_to_raw = soroban_value_to_raw (type val4);
   let val1_raw = {{ val1_to_raw val1 }};
   let val2_raw = {{ val2_to_raw val2 }};
   let val3_raw = {{ val3_to_raw val3 }};
   let val4_raw = {{ val4_to_raw val4 }};
   return {{ Values::vecobj_quad val1_raw val2_raw val3_raw val4_raw heap }};
};

let soroban_value_vecobj_5 val1 val2 val3 val4 val5 heap = do {
   let val1_to_raw = soroban_value_to_raw (type val1);
   let val2_to_raw = soroban_value_to_raw (type val2);
   let val3_to_raw = soroban_value_to_raw (type val3);
   let val4_to_raw = soroban_value_to_raw (type val4);
   let val5_to_raw = soroban_value_to_raw (type val5);
   let val1_raw = {{ val1_to_raw val1 }};
   let val2_raw = {{ val2_to_raw val2 }};
   let val3_raw = {{ val3_to_raw val3 }};
   let val4_raw = {{ val4_to_raw val4 }};
   let val5_raw = {{ val5_to_raw val5 }};
   return {{ Values::vecobj_quint val1_raw val2_raw val3_raw val4_raw val5_raw heap }};
};

let soroban_value_mapobj_0 heap = do {
   return {{ Values::mapobj_empty heap }};
};

let soroban_value_mapobj_1 k v heap = do {
   let k_to_raw = soroban_value_to_raw (type k);
   let k_raw = {{ k_to_raw k }};
   let v_to_raw = soroban_value_to_raw (type v);
   let v_raw = {{ k_to_raw v }};
   return {{ Values::mapobj_singleton k_raw v_raw heap }};
};

let soroban_value_mapobj_2 k1 v1 k2 v2 heap = do {
   let k1_to_raw = soroban_value_to_raw (type k1);
   let k1_raw = {{ k_to_raw k1 }};
   let v1_to_raw = soroban_value_to_raw (type v1);
   let v1_raw = {{ k_to_raw v1 }};
   let k2_to_raw = soroban_value_to_raw (type k2);
   let k2_raw = {{ k_to_raw k2 }};
   let v2_to_raw = soroban_value_to_raw (type v2);
   let v2_raw = {{ k_to_raw v2 }};
   return {{ Values::mapobj_pair k1_raw v1_raw k2_raw v2_raw heap }};
};


/*
 * Specs for the SDK code.
 */

/*
 * This is not a hypercall but we need to intercept it before it calls
 * string_new_from_linear_memory, as in order to do that it does a
 * pointer -> u32 cast that crux-mir can't handle.
 *
 * string_new_from_slice(env: Env, slice: &str) ->
 *    Result<StringObject, Self::Error>
 */
let string_new_from_slice_spec (n : Int) (smi : SorobanMIRItems) : MIRSetup () = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());
   // alternatively, get a Guest to override at a different point
   //self <- mir_alloc (mir_adt (smi.GuestType ()));
   //mir_points_to self (smi.GuestVal ());

   // get a string of length n for the argument
   contents <- mir_fresh_cryptol_var "string_new_from_slice.contents" {| String n |};

   // allocate and populate a reference to it
   ptr <- mir_alloc (mir_array n mir_u8);
   mir_points_to ptr (mir_term contents);

   // get a host heap model with space to allocate at least once
   heap <- mir_fresh_cryptol_var "values.string_new_from_slice.heap" {| Values::HostHeap |};
   mir_assert {{ Values::heap_has_space heap 1 }};

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function, taking a slice reference to the string reference
   mir_execute_func [self, mir_str_slice_value ptr];

   // allocate in the model
   let heap'v = {{ Values::strobj_dummy () heap }};
   let heap' = {{ heap'v.0 }};
   let v = {{ heap'v.1 }};

   // update the heap model
   soroban_hostheap_assert_state heap';

   // return the new object handle
   // XXX share this logic with return_ok (which is currently below and
   // needs to be moved up)
   let rettype = soroban_value_type_to_mir smi (type v);
   let mir_v = soroban_value_to_mir smi v;
   let ok = mir_enum_value (smi.ResultInfallibleType rettype) "Ok" [mir_v];
   mir_return ok;
};

/*
 * Create a new vector. Takes one argument of type Values::Raw::T.
 * If it's Values::void, the length of the new vector is 0. Otherwise
 * it must be a U32Val that gives the length.
 *
 * Write separate specs for the void and u32 cases. This makes the
 * type wrangling easier.
 *
 * vec_new(env: Env, c: RawVal) : VecObject
 */
let vec_new_empty_spec (smi : SorobanMIRItems) = do {

   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a host heap with space to allocate at least once
   heap <- mir_fresh_cryptol_var "values.vec_new/empty.heap" {| Values::HostHeap |};
   mir_assert {{ Values::heap_has_space heap 1 }};

   // get the argument (the Soroban-level Void value, but as a RawVal)
   let arg_val = {{ Values::void_to_raw Values::unit }};
   let arg_mir = soroban_value_to_mir smi arg_val;

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function
   mir_execute_func [self, arg_mir];

   /*
    * The function allocates space on the external (host-side) heap
    * and returns a handle to it. Allocate a space in our model of the
    * host-side heap.
    *
    * Because we aren't verifying the host-side function, we can just
    * use the handle we get back from our model as the return value.
    * However, if we wanted to actually verify the host-side function,
    * that wouldn't be good enough; the handle value might not be the
    * same. Instead, we'd need to create a fresh u32 for the actual
    * return value and assert that it and our model handle both
    * point to the right vector data.
    *
    * Downstream of here anything that uses the handle should be
    * checking the value pointed to, not the handle value itself,
    * because (like a pointer) the actual handle value isn't
    * meaningful, and furthermore, you can have two different
    * handles for two copies of the same vector and they should
    * be treated as equal vector objects.
    *
    * (In principle we could make our heap model accurate enough that
    * the handle values would match up, since it's a table index and
    * not an actual pointer. But that doesn't address the comparison
    * concerns. For the moment the model isn't exact either -- on the
    * host side there are two object tables, not one, and the bottom
    * bit of the handle chooses between them. It isn't clear so far
    * what the difference between them is, but it doesn't appear to be
    * something we need to model to verify contracts.)
    */
   let heap'v = {{ Values::vecobj_empty heap }};
   let heap' = {{ heap'v.0 }};
   let v = {{ heap'v.1 }};

   // update the heap
   soroban_hostheap_assert_state heap';

   // return the new object handle
   // XXX share this logic with return_ok (which is currently below and
   // needs to be moved up)
   let rettype = soroban_value_type_to_mir smi (type v);
   let mir_v = soroban_value_to_mir smi v;
   let ok = mir_enum_value (smi.ResultInfallibleType rettype) "Ok" [mir_v];
   mir_return ok;
};
let vec_new_nonempty_spec (smi : SorobanMIRItems) = do {

   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a host heap with space to allocate at least once
   heap <- mir_fresh_cryptol_var "values.vec_new/nonempty.heap" {| Values::HostHeap |};
   mir_assert {{ Values::heap_has_space heap 1 }};

   // get an argument
   n <- soroban_value_fresh "values.vec_new/nonempty.n" {| Values::U32T |};
   let native_n = {{ Values::u32_to_native n }};
   let mir_n = soroban_value_to_mir smi {{ Values::u32_to_raw n }};

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function
   mir_execute_func [self, mir_n];

   // need a value to put in the vector; should be the raw version of unit
   let dfl_raw = {{ Values::void_to_raw Values::unit }};

   // allocate in the model
   let heap'v = {{ Values::vecobj_n native_n dfl_raw heap }};
   let heap' = {{ heap'v.0 }};
   let v = {{ heap'v.1 }};

   // update the heap
   soroban_hostheap_assert_state heap';

   // return the new object handle
   // XXX share this logic with return_ok (which is currently below and
   // needs to be moved up)
   let rettype = soroban_value_type_to_mir smi (type v);
   let mir_v = soroban_value_to_mir smi v;
   let ok = mir_enum_value (smi.ResultInfallibleType rettype) "Ok" [mir_v];
   mir_return ok;
};

/*
 * Get the length of the vector v.
 *
 * vec_len(env: Env, v: VecObject) : U32Val
 */
let vec_len_spec (smi : SorobanMIRItems) = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get an argument
   v <- soroban_value_fresh "values.vec_len.v" {| Values::VecObjectT |};
   let mir_v = soroban_value_to_mir smi v;

   // get a host heap, which has a mapping for the VecObject
   heap <- mir_fresh_cryptol_var "values.vec_len.heap" {| Values::HostHeap |};
   mir_assert {{ Values::vecobj_valid_with_heap v heap }};

   // get the length
   let native_len = {{ Values::vecobj_len v heap }};
   let len = {{ Values::u32_from_native native_len }};

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function
   mir_execute_func [self, mir_v];

   // return the Values::U32::T length
   mir_return (mir_term len);
};

/*
 * Get index i of the vector v.
 *
 * i must be in bounds.
 *
 * vec_get(env: Env, v: VecObject, i: U32Val) : RawVal
 */
let vec_get_spec (smi : SorobanMIRItems) = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a vector argument
   v <- soroban_value_fresh "values.vec_get.v" {| Values::VecObjectT |};
   let mir_v = soroban_value_to_mir smi v;

   // get an index argument
   i <- soroban_value_fresh "values.vec_get.i" {| Values::U32T |};
   let native_i = {{ Values::u32_to_native i }};
   let mir_i = soroban_value_to_mir smi i;

   // get a host heap, which has a mapping for the VecObject
   heap <- mir_fresh_cryptol_var "values.vec_get.heap" {| Values::HostHeap |};
   mir_assert {{ Values::vecobj_valid_with_heap v heap }};

   // get the length, check bounds requirement
   let native_len = {{ Values::vecobj_len v heap }};
   mir_assert {{ native_i < native_len }};

   // get the value
   let ret = {{ Values::vecobj_get v i heap }};
   let mir_ret = soroban_value_to_mir smi ret;

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function
   mir_execute_func [self, mir_v, mir_i];

   // return the value
   mir_return (mir_term ret);
};

/*
 * Get index 0 of the vector v. Vector must not be empty.
 * Not sure why this is its own hypercall (vs. a wrapper around vec_get).
 *
 * vec_front(env: Env, v: VecObject) : RawVal
 */
//let vec_front_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Get index (len - 1) of the vector v. Vector must not be empty.
 *
 * vec_back(env: Env, v: VecObject) : RawVal
 */
//let vec_back_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Update index i of the vector v to value x. Returns the new
 * vector.
 *
 * i must be in bounds.
 *
 * vec_put(env: Env, v: VecObject, i: U32Val, x: RawVal) : VecObject
 */
//let vec_put_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Remove index i of the vector v. Returns the new smaller vector.
 *
 * i must be in bounds.
 *
 * vec_del(env: Env, v: VecObject, i: U32Val) : VecObject
 */
//let vec_del_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Inset at index i of the vector v. Returns the new larger vector.
 *
 * i must be in bounds.
 *
 * vec_ins(env: Env, v: VecObject, i: U32Val, x : RawVal) : VecObject
 */
//let vec_ins_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Insert value at the front. Returns the new larger vector.
 *
 * vec_push_front(env: Env, v: VecObject, x: RawVal) : VecObject
 */
//let vec_push_front_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Remove the value at the front. Vector must not be empty.
 *
 * Apparently equivalent to vec_del(v, 0), not sure why it's
 * its own hypercall.
 *
 * vec_pop_front(env: Env, v: VecObject) : RawVal)
 */
//let vec_pop_front_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Insert value at the end. Returns the new larger vector.
 *
 * vec_push_back(env: Env, v: VecObject, x: RawVal) : VecObject
 */
let vec_push_back_spec (smi : SorobanMIRItems) = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a previous vector (first argument)
   v <- soroban_value_fresh "values.vec_push_back.v" {| Values::VecObjectT |};
   let mir_v = soroban_value_to_mir smi v;

   // get a value to add (second argument)
   x <- soroban_value_fresh "values.vec_push_back.x" {| Values::RawT |};
   let mir_x = soroban_value_to_mir smi x;

   // get a host heap with space to allocate at least once
   heap <- mir_fresh_cryptol_var "values.vec_push_back.heap" {| Values::HostHeap |};
   mir_assert {{ Values::heap_has_space heap 1 }};

   // the heap must also have a mapping for the VecObject
   mir_assert {{ Values::vecobj_valid_with_heap v heap }};

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function
   mir_execute_func [self, mir_v, mir_x];

   // allocate in the model
   let heap'v = {{ Values::vecobj_addtail v x heap }};
   let heap' = {{ heap'v.0 }};
   let v = {{ heap'v.1 }};

   // update the heap
   soroban_hostheap_assert_state heap';

   // return the new object handle
   // XXX share this logic with return_ok (which is currently below and
   // needs to be moved up)
   let rettype = soroban_value_type_to_mir smi (type v);
   let mir_v = soroban_value_to_mir smi v;
   let ok = mir_enum_value (smi.ResultInfallibleType rettype) "Ok" [mir_v];
   mir_return ok;
};

/*
 * Remove the value at the end. Vector must not be empty.
 *
 * vec_pop_back(env: Env, v: VecObject) : RawVal
 */
//let vec_pop_back_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Concatenate two vecs. Total length must not overflow u32.
 * Returns the new vector.
 *
 * vec_append(env: Env, v1: VecObject, v2: VecObject) : VecObject
 */
//let vec_append_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Extract the range start-end as a new vector.
 * (Range appears to mean start through end - 1)
 * Indexes must be in bounds.
 *
 * vec_slice(env: Env, v: VecObject, start: U32Val, end: U32Val) : VecObject
 */
//let vec_slice_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Find the index of the first occurrence of x. Returns void if
 * there is none.
 *
 * vec_first_index_of(env: Env, v: VecObject, x: RawVal) : RawVal
 */
//let vec_first_index_of_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Find the index of the last occurrence of x. Returns void if
 * there is none.
 *
 * vec_last_index_of(env: Env, v: VecObject, x: RawVal) : RawVal
 */
//let vec_last_index_of_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Search for x. Returns two u32s in a u64. The lower one is
 * the vector index for the value. The upper one is either 1
 * (meaning the value in question is there) or 0 (meaning it's
 * not but that's where it would be / where to put it).
 *
 * Yes, it appears to return a Rust u64 and not a U64Val.
 *
 * vec_binary_search(env: Env, v: VecObject, x: RawVal) : u64
 */
//let vec_binary_search_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Create a new vector from the n RawVals at the given address a.
 *
 * vec_new_from_linear_memory(env: Env, a: U32Val, n: U32Val) : VecObject
 */
//let vec_new_from_linear_memory_spec (smi : SorobanMIRItems) = do {
//};

/*
 * Get all the values from the vector into a buffer at the given
 * address a. Not sure what happens if n doesn't match the length.
 *
 * vec_unpack_to_linear_memory(env: Env, v: VecObject,
 *                             a: U32Val, n: U32Val) : Void
 */
//let vec_unpack_to_linear_memory_spec (smi : SorobanMIRItems) = do {
//};

/*
 * This is not a hypercall but we need to intercept it before it calls
 * vec_new_from_linear_memory, as in order to do that it does a
 * pointer -> u32 cast that crux-mir can't handle.
 *
 * vec_new_from_slice(env: Env, vals: &[RawVal]) ->
 *    Result<VecObject, Self::Error>
 *
 * For the moment at least we need a separate copy of this for each
 * distinct length, because arrays of symbolic length cause problems.
 */
let vec_new_from_slice_spec (n : Int) (smi : SorobanMIRItems) : MIRSetup () = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());
   // alternatively, get a Guest to override at a different point
   //self <- mir_alloc (mir_adt (smi.GuestType ()));
   //mir_points_to self (smi.GuestVal ());

   // this is unfortunate but seems to be the only way to make it work
   // (passing in the contents causes problems)
   contents <- do {
      if eval_bool {{ `n == 0 }} then do {
         // The type annotation here is required or eval_list fails.
         return {{ [] : [n] Values::RawT }};
      }
      else if eval_bool {{ `n == 1 }} then do {
         contents <- soroban_raw1_fresh "values.vec_new_from_slice";
         return contents;
      }
      else if eval_bool {{ `n == 2 }} then do {
         contents <- soroban_raw2_fresh "values.vec_new_from_slice";
         return contents;
      }
      else if eval_bool {{ `n == 3 }} then do {
         contents <- soroban_raw3_fresh "values.vec_new_from_slice";
         return contents;
      }
      else if eval_bool {{ `n == 4 }} then do {
         contents <- soroban_raw4_fresh "values.vec_new_from_slice";
         return contents;
      }
      else if eval_bool {{ `n == 5 }} then do {
         contents <- soroban_raw5_fresh "values.vec_new_from_slice";
         return contents;
      }
      else do {
         let msg = "vec_new_from_slice: too many elements: ";
         run (fail (str_concat msg (show n)));
      };
   };

   // turn the contents into a SAW list and convert to MIR RawVals
   let mir_contents_list = list.map (soroban_value_to_mir smi) (eval_list contents);

   // get the corresponding MIR array
   let RawVal = soroban_value_type_to_mir smi {| Values::RawT |};
   let mir_contents_array = mir_array_value RawVal mir_contents_list;

   // allocate and populate a reference to it
   vals <- mir_alloc (mir_array n RawVal);
   mir_points_to vals mir_contents_array;

   // get a host heap model with space to allocate at least once
   heap <- mir_fresh_cryptol_var "values.vec_new_from_slice.heap" {| Values::HostHeap |};
   mir_assert {{ Values::heap_has_space heap 1 }};

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function, taking a slice reference to the array
   mir_execute_func [self, mir_slice_value vals];

   // allocate in the model
   let heap'v = {{ Values::vecobj_seq contents heap }};
   let heap' = {{ heap'v.0 }};
   let v = {{ heap'v.1 }};

   // rebind the SDK state
   soroban_hostheap_assert_state heap';

   // return the new object handle
   // XXX share this logic with return_ok (which is currently below and
   // needs to be moved up)
   let rettype = soroban_value_type_to_mir smi (type v);
   let mir_v = soroban_value_to_mir smi v;
   let ok = mir_enum_value (smi.ResultInfallibleType rettype) "Ok" [mir_v];
   mir_return ok;
};

/*
 * This is not a hypercall but we need to intercept it before it calls
 * vec_unpack_to_linear_memory, as in order to do that it does a
 * pointer -> u32 cast that crux-mir can't handle.
 *
 * vec_unpack_to_slice(env: Env, vec: VecObject, vals: &mut [RawVal]) ->
 *    Result<Void, Self::Error>
 *
 * For the moment at least we need a separate copy of this for each
 * distinct length, because arrays of symbolic length cause problems.
 */
let vec_unpack_to_slice_spec (n : Int) (smi : SorobanMIRItems) : MIRSetup () = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());
   // alternatively, get a Guest to override at a different point
   //self <- mir_alloc (mir_adt (smi.GuestType ()));
   //mir_points_to self (smi.GuestVal ());

   // this is unfortunate but seems to be the only way to make it work
   // (passing in the contents causes problems)
   contents <- do {
      if eval_bool {{ `n == 0 }} then do {
         // The type annotation here is required or eval_list fails.
         return {{ [] : [n] Values::RawT }};
      }
      else if eval_bool {{ `n == 1 }} then do {
         contents <- soroban_raw1_fresh "values.vec_unpack_to_slice";
         return contents;
      }
      else if eval_bool {{ `n == 2 }} then do {
         contents <- soroban_raw2_fresh "values.vec_unpack_to_slice";
         return contents;
      }
      else if eval_bool {{ `n == 3 }} then do {
         contents <- soroban_raw3_fresh "values.vec_unpack_to_slice";
         return contents;
      }
      else if eval_bool {{ `n == 4 }} then do {
         contents <- soroban_raw4_fresh "values.vec_unpack_to_slice";
         return contents;
      }
      else if eval_bool {{ `n == 5 }} then do {
         contents <- soroban_raw5_fresh "values.vec_unpack_to_slice";
         return contents;
      }
      else do {
         let msg = "vec_unpack_to_slice: too many elements: ";
         run (fail (str_concat msg (show n)));
      };
   };

   // turn the contents into a SAW list and convert to MIR RawVals
   let mir_contents_list = list.map (soroban_value_to_mir smi) (eval_list contents);

   // get the corresponding MIR array
   let RawVal = soroban_value_type_to_mir smi {| Values::RawT |};
   let mir_contents_array = mir_array_value RawVal mir_contents_list;

   // allocate and populate a reference to it
   vals <- mir_alloc_mut (mir_array n RawVal);
   mir_points_to vals mir_contents_array;

   // get a host heap model
   heap <- mir_fresh_cryptol_var "values.vec_unpack_to_slice.heap" {| Values::HostHeap |};

   // get a vecobject
   vecobj_val <- soroban_value_fresh "values.vec_unpack_to_slice.vecobj" {| Values::VecObjectT |};
   let vecobj_mir = soroban_value_to_mir smi vecobj_val;

   // the vec must appear in the heap
   mir_assert {{ Values::vecobj_valid_with_heap vecobj_val heap }};

   // the length must be correct
   mir_assert {{ Values::vecobj_len vecobj_val heap == `n }};

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function, taking a slice reference to the array
   mir_execute_func [self, vecobj_mir, mir_slice_value vals];

   // the heap doesn't change
   soroban_hostheap_assert_state heap;

   // get the values out of the heap
   let contents' = {{ Values::vecobj_getall`{n} vecobj_val heap }};
   let mir_contents_list' = list.map (soroban_value_to_mir smi) (eval_list contents');
   let mir_contents_array' = mir_array_value RawVal mir_contents_list';

   // update the reference to point to the values
   mir_points_to vals mir_contents_array';

   // return the Soroban void value
   // XXX share this logic with return_ok (which is currently below and
   // needs to be moved up)
   let ret = {{ Values::unit }};
   let rettype = soroban_value_type_to_mir smi (type ret);
   let mir_ret = soroban_value_to_mir smi ret;
   let ok = mir_enum_value (smi.ResultInfallibleType rettype) "Ok" [mir_ret];
   mir_return ok;
};


/*
 * Construct a fresh map key (which is a string/symbol) of length m.
 */
let soroban_fresh_mapkey (m : Int) = do {
   // make a fresh string
   keycontents <- mir_fresh_cryptol_var "values.map_unpack_to_slice.val" {| String m |};
   // make a Cryptol-side key using the short symbol encoding
   // (the keys will be Symbol::T values)
   let keysym = {{ Values::symbol_from_native keycontents }};
   let keyval = {{ Values::symbol_to_raw keysym }};
   // make a MIR-level string slice
   ref <- mir_alloc (mir_array m mir_u8);
   mir_points_to ref (mir_term keycontents);
   let mir_keycontents = mir_str_slice_value ref;
   // produce both
   return (mir_keycontents, keyval);
};

/*
 * This is not a hypercall but we need to intercept it before it calls
 * map_unpack_to_linear_memory, as in order to do that it does a
 * pointer -> u32 cast that crux-mir can't handle.
 *
 * map_unpack_to_slice(env: Env, map: MapObject, keys: &[&str], vals: &mut [RawVal]) ->
 *    Result<Void, Self::Error>
 *
 * For the moment at least we need a separate copy of this for each
 * distinct length, because arrays of symbolic length cause problems.
 */
let map_unpack_to_slice_spec (ms : [Int]) (smi : SorobanMIRItems) : MIRSetup () = do {
   // get an environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());
   // alternatively, get a Guest to override at a different point
   //self <- mir_alloc (mir_adt (smi.GuestType ()));
   //mir_points_to self (smi.GuestVal ());

   let n = length ms;

   // only support up to 9 characters because we use the short symbol encoding internally
   _ <- list.mapM (\m -> mir_assert {{ `m <= 9 }}) ms;

   // make n fresh keys
   pairs <- list.mapM soroban_fresh_mapkey ms;
   let (mir_keycontents_list, rawkeys_list : [Term]) = list.unzip pairs;
   let rawkeys = list_term rawkeys_list;

   // now make a MIR array of references
   //let keys_type = mir_array m mir_u8;
   let keys_type = mir_ref mir_str;
   let mir_keycontents_array = mir_array_value keys_type mir_keycontents_list;

   // allocate and populate a reference to it
   keys <- mir_alloc (mir_array n keys_type);
   mir_points_to keys mir_keycontents_array;

   // now make the value outputs
   valcontents <- do {
      if eval_bool {{ `n == 0 }} then do {
         // The type annotation here is required or eval_list fails.
         return {{ [] : [n] Values::RawT }};
      }
      else if eval_bool {{ `n == 1 }} then do {
         valcontents <- soroban_raw1_fresh "values.vec_unpack_to_slice";
         return valcontents;
      }
      else if eval_bool {{ `n == 2 }} then do {
         valcontents <- soroban_raw2_fresh "values.vec_unpack_to_slice";
         return valcontents;
      }
      else if eval_bool {{ `n == 3 }} then do {
         valcontents <- soroban_raw3_fresh "values.vec_unpack_to_slice";
         return valcontents;
      }
      else if eval_bool {{ `n == 4 }} then do {
         valcontents <- soroban_raw4_fresh "values.vec_unpack_to_slice";
         return valcontents;
      }
      else if eval_bool {{ `n == 5 }} then do {
         valcontents <- soroban_raw5_fresh "values.vec_unpack_to_slice";
         return valcontents;
      }
      else do {
         let msg = "vec_unpack_to_slice: too many elements: ";
         run (fail (str_concat msg (show n)));
      };
   };
   let mir_vals_list = list.map (soroban_value_to_mir smi) (eval_list valcontents);
   let RawVal = soroban_value_type_to_mir smi {| Values::RawT |};
   let mir_vals_array = mir_array_value RawVal mir_vals_list;
   let vals_type = mir_array n RawVal;
   vals <- mir_alloc_mut vals_type;
   mir_points_to vals mir_vals_array;

   // get a host heap model
   heap <- mir_fresh_cryptol_var "values.map_unpack_to_slice.heap" {| Values::HostHeap |};

   // get a mapobject
   mapobj_val <- soroban_value_fresh "values.map_unpack_to_slice.mapobj" {| Values::MapObjectT |};
   let mapobj_mir = soroban_value_to_mir smi mapobj_val;

   // the map must appear in the heap
   mir_assert {{ Values::mapobj_valid_with_heap mapobj_val heap }};

   // bind the SDK state
   soroban_hostheap_assert_state heap;

   // call the function, taking a slice reference to the outer array
   mir_execute_func [self, mapobj_mir, mir_slice_value keys, mir_slice_value vals];

   // the heap doesn't change
   soroban_hostheap_assert_state heap;

   // get the values out
   let vals_contents' = {{ Values::mapobj_multiget rawkeys mapobj_val heap }};
   let mir_vals_contents' = list.map (soroban_value_to_mir smi) (eval_list vals_contents');
   let mir_vals_array' = mir_array_value RawVal mir_vals_contents';

   // update the reference to point to the values
   mir_points_to vals mir_vals_array';

   // return the Soroban void value
   // XXX share this logic with return_ok (which is currently below and
   // needs to be moved up)
   let ret = {{ Values::unit }};
   let rettype = soroban_value_type_to_mir smi (type ret);
   let mir_ret = soroban_value_to_mir smi ret;
   let ok = mir_enum_value (smi.ResultInfallibleType rettype) "Ok" [mir_ret];
   mir_return ok;
};


/*
 * Construct the "overrides" (checked or admitted SAW theorems, in
 * this case admitted) for the SDK host-stored-value interface.
 */
let make_hostvalue_overrides (smi : SorobanMIRItems) mod features = do {
   string_new_from_slice_overrides <- do {
      if string_list.elem "string_new_from_slice" features then do {
         let make (n : Int) : TopLevel MIRSpec = do {
            spec <- mir_unsafe_assume_spec mod
               // either of these is a possible interception point
               // (the first just calls the second)
               "soroban_sdk::env::{impl#9}::string_new_from_slice"
               //"soroban_env_guest::guest::{impl#0}::string_new_from_slice"
               (string_new_from_slice_spec n smi);
            return spec;
         };
         // need a separate instance for each length. go up to 11
         spec_0 <- make 0;
         spec_1 <- make 1;
         spec_2 <- make 2;
         spec_3 <- make 3;
         spec_4 <- make 4;
         spec_5 <- make 5;
         spec_6 <- make 6;
         spec_7 <- make 7;
         spec_8 <- make 8;
         spec_9 <- make 9;
         spec_10 <- make 10;
         spec_11 <- make 11;
         return [spec_0, spec_1, spec_2, spec_3, spec_4, spec_5,
                 spec_6, spec_7, spec_8, spec_9, spec_10, spec_11];
      }
      else
         return [];
   };
   vec_new_overrides <- do {
      if string_list.elem "vec_new" features then do {
         vec_new_empty_spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_new"
            (vec_new_empty_spec smi);
         vec_new_nonempty_spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_new"
            (vec_new_nonempty_spec smi);
         return [vec_new_empty_spec, vec_new_nonempty_spec];
      }
      else
         return [];
   };
   vec_len_overrides <- do {
      if string_list.elem "vec_len" features then do {
         vec_len_spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_len"
            (vec_len_spec smi);
         return [vec_len_spec];
      }
      else
         return [];
   };
   vec_get_overrides <- do {
      if string_list.elem "vec_get" features then do {
         vec_get_spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_get"
            (vec_get_spec smi);
         return [vec_get_spec];
      }
      else
         return [];
   };
   vec_push_back_overrides <- do {
      if string_list.elem "vec_push_back" features then do {
         spec <- mir_unsafe_assume_spec mod
            "soroban_sdk::env::{impl#12}::vec_push_back"
            (vec_push_back_spec smi);
         return [spec];
      }
      else
         return [];
   };
   vec_new_from_slice_overrides <- do {
      if string_list.elem "vec_new_from_slice" features then do {
         let make (n : Int) : TopLevel MIRSpec = do {
            spec <- mir_unsafe_assume_spec mod
               // either of these is a possible interception point
               // (the first just calls the second)
               "soroban_sdk::env::{impl#9}::vec_new_from_slice"
               //"soroban_env_guest::guest::{impl#0}::vec_new_from_slice"
               (vec_new_from_slice_spec n smi);
            return spec;
         };
         spec_0 <- make 0;
         spec_1 <- make 1;
         spec_2 <- make 2;
         spec_3 <- make 3;
         spec_4 <- make 4;
         spec_5 <- make 5;
         return [spec_0, spec_1, spec_2, spec_3, spec_4, spec_5];
      }
      else
         return [];
   };
   vec_unpack_to_slice_overrides <- do {
      if string_list.elem "vec_unpack_to_slice" features then do {
         let make (n : Int) : TopLevel MIRSpec = do {
            spec <- mir_unsafe_assume_spec mod
               // either of these is a possible interception point
               // (the first just calls the second)
               "soroban_sdk::env::{impl#9}::vec_unpack_to_slice"
               //"soroban_env_guest::guest::{impl#0}::vec_unpack_to_slice"
               (vec_unpack_to_slice_spec n smi);
            return spec;
         };
         spec_0 <- make 0;
         spec_1 <- make 1;
         spec_2 <- make 2;
         spec_3 <- make 3;
         spec_4 <- make 4;
         spec_5 <- make 5;
         return [spec_0, spec_1, spec_2, spec_3, spec_4, spec_5];
      }
      else
         return [];
   };
   map_unpack_to_slice_overrides <- do {
      if string_list.elem "map_unpack_to_slice" features then do {
         let make (ms : [Int]) : TopLevel MIRSpec = do {
            spec <- mir_unsafe_assume_spec mod
               // either of these is a possible interception point
               // (the first just calls the second)
               "soroban_sdk::env::{impl#9}::map_unpack_to_slice"
               //"soroban_env_guest::guest::{impl#0}::map_unpack_to_slice"
               (map_unpack_to_slice_spec ms smi);
            return spec;
         };
         // For now make just the one we're going to use (XXX: add more later,
         // though we'll ultimately need a lot unless we can get it to work with
         // indeterminate heterogeneous slices...)
         spec_5_9 <- make [5, 9];
         return [spec_5_9];
      }
      else
         return [];
   };
   return (list.concats [
      string_new_from_slice_overrides,
      vec_new_overrides,
      vec_len_overrides,
      vec_get_overrides,
      vec_push_back_overrides,
      vec_new_from_slice_overrides,
      map_unpack_to_slice_overrides
   ]);
};


////////////////////////////////////////////////////////////
// SDK storage interface

/*
 * Spec for the storage interface.
 *
 * To (maybe) improve clarity we refer to the moving parts of the
 * storage interface as follows:
 *    - "storage" is the name of the overall interface and concept
 *    - "store" is the name of the data structure we use to model the contents
 *
 * There are three parts to the code:
 *    - a Cryptol implementation of the store
 *    - a SAW wrapper around the Cryptol
 *    - SAW specs for the Rust interface
 *
 * Note that currently the model version of the code (the Cryptol and
 * the SAW wrapper) requires that contract specs explicitly update the
 * storage state after manipulating the store, but the Rust interface
 * specs (necessarily) do this internally. This is on the one hand
 * similar, but it also means that contract specs have to do extra
 * work/operations that have no equivalent in their Rust code and I'm
 * not sure that's a good way to do things. That is, I'm suggesting
 * that the SAW store ops below that just manipulate store values
 * should be extended to storage ops that update the state and thus
 * apply to the whole storage model. This wants some thought.
 *
 * For now at least the Cryptol-level store is written purely in terms
 * of Values::Raw::T and the type wrapping happens here. It's possible
 * that should change, but we'll see.
 */

/*
 * The model of the storage contents. Because the ghost state we keep
 * it in is mutable, it doesn't need to be passed around and can live
 * as a global here. Wrap it in a type to help prevent accidents.
 */
typedef SorobanStorageState = {
   ghoststate : Ghost
};

soroban_storage_state <- do {
   ghoststate <- declare_ghost_state "Soroban::storage";
   let state = {
      ghoststate = ghoststate
   };
   return state;
};

/*
 * Assert that the internally tracked model of the storage contents
 * matches another Store.
 */
let soroban_storage_assert_state (store : Term /* Store */) : MIRSetup () = do {
   mir_ghost_value soroban_storage_state.ghoststate store;
};

/*
 * Ops on store values. These are basically type wrappers around
 * the Cryptol version of the Store.
 */

/*
 * Check if the a store has a given key. The key can be any value
 * type. Returns a Cryptol Bool.
 */
let soroban_store_has (store : Term /* Store */) (k : Term) =
   let k_to_raw = soroban_value_to_raw (type k) in
   {{ Store::has store (k_to_raw k) }};

/*
 * Get the contents in a store under a given key, as type tv.
 * The key can be any value type.
 *
 * Returns a Term with Cryptol type Option::T (Option::T tv).
 * If the outer Option is None, there was no such key in the store.
 * If the inner Option is None, the value found was not the expected type.
 *
 * (This is apparently the same interface as the SDK Rust code.)
 */
let soroban_store_get (store : Term /* Store */) (k : Term) (tv : Type) =
   let k_to_raw = soroban_value_to_raw (type k) in
   let v_from_raw = soroban_value_from_raw tv in
   {{ Option::fmap (Store::get store (k_to_raw k)) v_from_raw }};

/*
 * Set the contents in a store under a given key. The key and value
 * can be any value type.
 *
 * Returns a new Cryptol Store value.
 */
let soroban_store_set (store : Term /* Store */) (k : Term) (v : Term) =
   let k_to_raw = soroban_value_to_raw (type k) in
   let v_to_raw = soroban_value_to_raw (type v) in
   {{ Store::set store (k_to_raw k) (v_to_raw v) }};

/*
 * Specs for the SDK code.
 */

/*
 * Helper for returning Ok from a Rust function.
 */
let return_ok (smi : SorobanMIRItems) (x : Term) : MIRSetup () =
   mir_return
      (mir_enum_value
         (smi.ResultInfallibleType (soroban_value_type_to_mir smi (type x)))
         "Ok"
         [soroban_value_to_mir smi x]);

/*
 * Spec for has_contract_data()
 */
let storage_has_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.has.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.has.k" {| Values::RawT |};
   // XXX: should assert that k has a valid type tag

   soroban_storage_assert_state store;

   mir_execute_func [self, soroban_value_to_mir smi k];

   soroban_storage_assert_state store;

   return_ok smi {{ Values::bool_from_native (Store::has store k) }};
};

/*
 * Spec for get_contract_data()
 */
let storage_get_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.get.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.get.k" {| Values::RawT |};
   // XXX: should assert that k has a valid type tag

   // XXX is it really wrong to call get without first calling has?
   // seems unusual, and also inconsistent with the return type of
   // get.
   mir_precond {{ Store::has store k }};
   soroban_storage_assert_state store;

   mir_execute_func [self, soroban_value_to_mir smi k];

   soroban_storage_assert_state store;

   // XXX probably relatedly, this doesn't seem to be able to
   // return failure. But, this seems like it will do the wrong
   // thing if the type in the store is wrong...
   return_ok smi {{ (Store::get store k).value }};
};

/*
 * Spec for put_contract_data
 *
 * Note that put_contract_data is the internal function where we cut
 * off symbolic execution with a spec. The user-facing interface is
 * env.storage.set(). This is why some things are called "set" and
 * others are "put".
 */
let storage_put_spec (smi : SorobanMIRItems) = do {
   store <- mir_fresh_cryptol_var "storage.put.store" {| Store::T |};

   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   k <- soroban_value_fresh "storage.put.k" {| Values::RawT |};
   v <- soroban_value_fresh "storage.put.v" {| Values::RawT |};
   // XXX: should assert that k and v have valid type tags

   let k_val = soroban_value_to_mir smi k;
   let v_val = soroban_value_to_mir smi v;

   soroban_storage_assert_state store;

   mir_execute_func [self, k_val, v_val];

   soroban_storage_assert_state {{ Store::set store k v }};

   // Return the SDK void value.
   return_ok smi {{ Values::unit }};
};

/*
 * Construct the "overrides" (checked or admitted SAW theorems, in
 * this case admitted) for the SDK storage interface.
 */
let make_storage_overrides (smi : SorobanMIRItems) mod features = do {
   if string_list.elem "storage" features then do {
      has_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::has_contract_data"
         (storage_has_spec smi);
      get_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::get_contract_data"
         (storage_get_spec smi);
      put_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::put_contract_data"
         (storage_put_spec smi);
      return [has_spec, get_spec, put_spec];
   }
   else
      return [];
};


////////////////////////////////////////////////////////////
// SDK logging interface

/*
 * Spec for the logging interface.
 *
 * Similarly to the storage interface, we name things as follows:
 *    - "logging" is the name of the overall interface and concept
 *    - "log" is the name of the data structure we use to model the contents
 *
 * There are three parts to this code:
 *    - a Cryptol model of the log
 *    - ghost state and glue for handling the model in SAW
 *    - SAW specs for the Rust interface
 *
 * For the time being we model the log just by counting the number of
 * messages logged.
 */

typedef SorobanLoggingState = {
   ghoststate : Ghost
};

soroban_logging_state <- do {
   ghoststate <- declare_ghost_state "Soroban::logging";
   let state = {
      ghoststate = ghoststate
   };
   return state;
};

/*
 * Assert equality of the internally tracked model of the log contents
 * with a new Log.
 */
let soroban_logging_assert_state (log : Term /* Log */) : MIRSetup () = do {
   mir_ghost_value soroban_logging_state.ghoststate log;
};

/*
 * We don't need to provide SAW-level ops on logs because the
 * Cryptol-level ops are sufficient.
 */

/*
 * Specs for the SDK code.
 *
 * We intercept/override at the hypercall level in order to avoid
 * dealing directly with the string wrangling that happens in the
 * logging code.
 */

let log_fmt_values_spec (smi : SorobanMIRItems) = do {
   // get a fresh environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a host heap with space to allocate at least once
   heap <- mir_fresh_cryptol_var "log_fmt_values.heap" {| Values::HostHeap |};

   // get a fresh log
   log <- mir_fresh_cryptol_var "log_fmt_values.log" {| Log::T |};

   // Get some args. The first arg is a StringObject, the second a
   // VecObject.
   fmt_val <- soroban_value_fresh "log_fmt_values.fmt" {| Values::StringObjectT |};
   args_val <- soroban_value_fresh "log_fmt_values.args" {| Values::VecObjectT |};

   // Assert that both exist in the heap.
   mir_assert {{ Values::strobj_valid_with_heap fmt_val heap }};
   mir_assert {{ Values::vecobj_valid_with_heap args_val heap }};

   // get MIR versions of the args
   let fmt_mir = soroban_value_to_mir smi fmt_val;
   let args_mir = soroban_value_to_mir smi args_val;

   // bind the SDK state
   soroban_hostheap_assert_state heap;
   soroban_logging_assert_state log;

   // call the function
   mir_execute_func [self, fmt_mir, args_mir];

   // update the log state
   let log' = {{ Log::add log }};

   // assert the updated SDK state (heap does not change)
   soroban_hostheap_assert_state heap;
   soroban_logging_assert_state log';

   // Return the SDK void value.
   return_ok smi {{ Values::unit }};
};

/*
 * Construct the "overrides" (checked or admitted SAW theorems, in
 * this case admitted) for the SDK storage interface.
 */
let make_logging_overrides (smi : SorobanMIRItems) mod features = do {
   if string_list.elem "logging" features then do {
      fmt_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::log_fmt_values"
         (log_fmt_values_spec smi);
      return [fmt_spec];
   }
   else
      return [];
};


////////////////////////////////////////////////////////////
// SDK events interface

/*
 * Spec for the events interface.
 *
 * We name things as follows:
 *    - "events" is the name of the overall interface and concept
 *    - "eventlog" is the name of the data structure we use to model
 *      the contents
 *
 * There are three parts to this code:
 *    - a Cryptol model of the event log
 *    - ghost state and glue for handling the model in SAW
 *    - SAW specs for the Rust interface
 */

typedef SorobanEventsState = {
   ghoststate : Ghost
};

soroban_events_state <- do {
   ghoststate <- declare_ghost_state "Soroban::events";
   let state = {
      ghoststate = ghoststate
   };
   return state;
};

/*
 * Extract the internally tracked model of the event log.
 *
 * There isn't a get operation for SAWscript ghost variables (yet) but
 * allocating a fresh var and asserting equality to the existing state
 * is an adequate workaround.
 *
 * Note that it's ok to do this using the implicitly defined
 * bit-level/SMT-level equality inside mir_ghost_value; it will get us
 * a model that's physically identical to the current one. Then we can
 * check for equivalence between that one and another one using the
 * proper equivalence function.
 */
let soroban_events_get_state () : MIRSetup Term = do {
   state <- mir_fresh_cryptol_var "Soroban::events::get_state" {| EventLog::T |};
   mir_ghost_value soroban_events_state.ghoststate state;
   return state;
};

/*
 * Assert equivalence of the internally tracked model of the event log
 * contents (what we saw when executing) with a new EventLog (what's
 * expected).
 *
 * XXX: for now, don't use EventLog::equiv. It tickles saw-script #2035,
 * which is not trivial to deal with (especially since dealing with it
 * in this context requires some way to tell SAW that EventLog::equiv
 * is an equivalence suitable for its concerns).
 *
 * Since for the time being at least we're verifying two copies of the
 * same heap model, as long as we do the same host allocations in the
 * same order in specs and the Rust code we'll get the same handles back
 * and we can get away with using bit equality of host heap handles for
 * comparison.
 */
let soroban_events_assert_state (log : Term /* EventLog */) : MIRSetup () = do {
   //seenlog <- soroban_events_get_state ();
   //mir_assert {{ EventLog::equiv seenlog log }};
   mir_ghost_value soroban_events_state.ghoststate log;
};

/*
 * Only certain types are allowed in event topics. The top level must
 * be either unit, a single value, or a tuple of arity 2, 3, or 4.
 * Longer tuples are prohibited.
 *
 * Beneath that, no contained value is supposed to be a Vec, Map,
 * Bytes longer than 32, BytesN longer than 32, or a contract.
 *
 * I think this means that nested tuples, which manifest at the value
 * level as vectors, are prohibited, although that's not absolutely
 * 100% clear.
 *
 * If so, though, it rules out anything that contains sub-values,
 * which is convenient for the purposes of checking that only legal
 * types are present.
 *
 * Don't allow Raw::T. I suspect that the Rust code probably does
 * allow raw values as long as the type tag corresponds to something
 * allowed, and should check up on that, but for the moment it seems
 * like a bad idea, and unnecessary, to allow it.
 */
let soroban_events_legal_in_topic (x: Term) =
   let t = type x in
   if type_eq t {| Values::VoidT |} then {{ True }}
   else if type_eq t {| Values::BoolT |} then {{ True }}
   else if type_eq t {| Values::U32T |} then {{ True }}
   else if type_eq t {| Values::SymbolT |} then {{ True }}
   else if type_eq t {| Values::VecObjectT |} then {{ False }}
   else if type_eq t {| Values::RawT |} then {{ False }}
   else
      run (fail (str_concat (show t) " cannot be used as an event topic"));

/*
 * Headache: we need a second copy of this that operates on Raw::T and
 * uses Cryptol-level type tests on the type tags. We can't branch on
 * model-level values in SAWscript.
 *
 * This one also can't crash because it's used to constrain inputs.
 */
let soroban_events_legal_in_topic' (x: Term) =
   {{
      if Values::raw_is_void x then True
      | Values::raw_is_bool x then True
      | Values::raw_is_u32 x then True
      | Values::raw_is_symbol x then True
      | Values::raw_is_vec x then False
      else False
   }};

/*
 * Ops on the event log. These are basically type wrappers around
 * the Cryptol version of the event log.
 */

/*
 * Cons up the topic for an event.
 *
 * An event can be void/unit, a single value, or a tuple of arity 2-4.
 * Only some types are allowed to appear.
 *
 * These functions serve to both construct the underlying VecObject
 * and also to check the legality of the types.
 *
 * They return a Cryptol-level pair (heap', topic).
 *
 * For now you must thread a heap through explicitly. In principle we
 * could transparently attach to a heap via ghost state (the first
 * version of this code did), but for the moment there are two
 * problems with that:
 *
 * 1. In general there are multiple heap models. For each function we
 * handle there are two: one that is manipulated by the spec, and one
 * that is manipulated by the code. The latter happens via overrides
 * of the functions _it_ calls, but those overrides are themselves
 * specs and also have two heap models. (Eventually the bottommost
 * layer of leaf functions relates its model directly to the memory
 * state of the allocator. In principle, at least; we don't get that
 * far because we stop at the hypercall layer and the whole purpose of
 * the host heap is that it's on the other side of the hypercall
 * layer. Because of that, and because we mostly have exactly two
 * layers of specs (one for contracts and one for hypercalls, with
 * most of the guest-side SDK code being executed as if it's part of
 * the contract) it's tempting to also just declare two copies of the
 * heap model and bind explicitly to them. These functions here are
 * allocation helpers for specs for contracts that post events, so
 * they'll always be intended to manipulate the contract-side heap
 * model. However, it's wrong to do it that way. Furthermore, in the
 * absence of sufficient organizing features in SAWscript (probably
 * either stronger types or stronger modules would do) it will be easy
 * to mix things up and call code that implicitly attaches to the
 * wrong heap model, and then things will mysteriously not work in
 * ways that are bound to be hard to figure out.
 *
 * 2. More pragmatically, right now we don't have a way to _update_ a
 * piece of ghost state, only assert about it, which means that we can
 * get a heap, then allocate and generate an updated heap, but after
 * that we have no way to put the updated heap back, and that's a
 * blocker.
 *
 * Note that the original version of this code did actually bind to
 * an implicit heap in ghost state, and it's much nicer that way, so
 * if the situation described above improves one should definitely
 * consider reverting portions of the commit that changed that (which
 * is also the one that added this comment). But don't revert the
 * whole thing as the original circumstances were that it was
 * accidentally using the _wrong_ heap.
 */

let soroban_events_mktopic_0 heap = do {
   return {{ Values::vecobj_empty heap }};
};

let soroban_events_mktopic_1 val heap = do {
   mir_assert (soroban_events_legal_in_topic val);
   let val_to_raw = soroban_value_to_raw (type val);
   let val_raw = {{ val_to_raw val }};
   return {{ Values::vecobj_singleton val_raw heap }};
};

let soroban_events_mktopic_2 val1 val2 heap = do {
   mir_assert (soroban_events_legal_in_topic val1);
   mir_assert (soroban_events_legal_in_topic val2);
   let val1_to_raw = soroban_value_to_raw (type val1);
   let val2_to_raw = soroban_value_to_raw (type val2);
   let val1_raw = {{ val1_to_raw val1 }};
   let val2_raw = {{ val2_to_raw val2 }};
   return {{ Values::vecobj_pair val1_raw val2_raw heap }};
};

let soroban_events_mktopic_3 val1 val2 val3 heap = do {
   mir_assert (soroban_events_legal_in_topic val1);
   mir_assert (soroban_events_legal_in_topic val2);
   mir_assert (soroban_events_legal_in_topic val3);
   let val1_to_raw = soroban_value_to_raw (type val1);
   let val2_to_raw = soroban_value_to_raw (type val2);
   let val3_to_raw = soroban_value_to_raw (type val3);
   let val1_raw = {{ val1_to_raw val1 }};
   let val2_raw = {{ val2_to_raw val2 }};
   let val3_raw = {{ val3_to_raw val3 }};
   return {{ Values::vecobj_triple val1_raw val2_raw val3_raw heap }};
};

let soroban_events_mktopic_4 val1 val2 val3 val4 heap = do {
   mir_assert (soroban_events_legal_in_topic val1);
   mir_assert (soroban_events_legal_in_topic val2);
   mir_assert (soroban_events_legal_in_topic val3);
   mir_assert (soroban_events_legal_in_topic val4);
   let val1_to_raw = soroban_value_to_raw (type val1);
   let val2_to_raw = soroban_value_to_raw (type val2);
   let val3_to_raw = soroban_value_to_raw (type val3);
   let val4_to_raw = soroban_value_to_raw (type val4);
   let val1_raw = {{ val1_to_raw val1 }};
   let val2_raw = {{ val2_to_raw val2 }};
   let val3_raw = {{ val3_to_raw val3 }};
   let val4_raw = {{ val4_to_raw val4 }};
   return {{ Values::vecobj_quad val1_raw val2_raw val3_raw val4_raw heap }};
};

/*
 * Get a fresh topic. So far we seem to be able to avoid having
 * separate versions for lengths 0 through 4. We just get all four
 * possible values and use a suitable get variant that returns unit
 * for out-of-range values.
 */
let soroban_events_fresh_topic name heap = do {
   t <- soroban_value_fresh name {| Values::VecObjectT |};
   mir_assert {{ Values::vecobj_valid_with_heap t heap }};
   mir_assert {{ Values::vecobj_len t heap <= 4 }};
   let val1 = {{ Values::vecobj_get t 0 heap }};
   let val2 = {{ Values::vecobj_get t 1 heap }};
   let val3 = {{ Values::vecobj_get t 2 heap }};
   let val4 = {{ Values::vecobj_get t 3 heap }};
   mir_assert (soroban_events_legal_in_topic' val1);
   mir_assert (soroban_events_legal_in_topic' val2);
   mir_assert (soroban_events_legal_in_topic' val3);
   mir_assert (soroban_events_legal_in_topic' val4);
   return t;
};

/*
 * Publish an event.
 *    - events should be an EventLog.
 *    - topic should be constructed from one of the mktopic functions above
 *    - value can be any value type
 *
 * It would be tidier if the topic could be a Cryptol tuple of Soroban
 * values instead of needing to be consed explicitly with a special
 * function. However, it's not clear how to assert about legal topic
 * types in that setup.
 */
let soroban_events_publish (events : Term) (topic : Term) (value : Term) = do {
   let value_to_raw = soroban_value_to_raw (type value);
   let raw_value = {{ value_to_raw value }};
   let events' = {{ EventLog::add events topic raw_value }};
   return events';
};

/*
 * Specs for the SDK code.
 */

/*
 * Env::contract_event() is the underlying interface for
 * Env::events().publish(). We intercept things at this level because
 * at this point the values have been unwrapped to RawVal, which has
 * significant advantages:
 *    - we don't have to worry about what the actual types of the
 *      values are, only that they're valid;
 *    - the function's monomorphic, so we only need one copy of the
 *      spec and we don't have to grope about for the monomorphized
 *      names of various versions generated by the compiler.
 */
let contract_event_spec (smi : SorobanMIRItems) = do {
   // get a fresh environment
   self <- mir_alloc (mir_adt (smi.EnvType ()));
   mir_points_to self (smi.EnvVal ());

   // get a heap
   heap <- mir_fresh_cryptol_var "contract_event.heap" {| Values::HostHeap |};

   // get a fresh event log
   elog <- mir_fresh_cryptol_var "events.publish.elog" {| EventLog::T |};

   // get a fresh topic
   //
   // At the user-facing level the topic is a tuple of 0-4 elements,
   // which are I think typically Symbols but can be anything that's
   // legal in topics (there are some other restrictions, see above).
   //
   // This always appears at this level as a VecObject. It is not
   // unwrapped to a RawVal before making the hypercall out of the
   // Soroban guest. Don't ask me why, but I guess it's more type-safe
   // this way and thus generally preferable.
   //
   // It isn't clear to me exactly what happens with single elements
   // given that Rust doesn't have monoples, but there's enough
   // trait-based type conversion magic going on for any value to be
   // promoted to a Vec of length 1 (Vec is the SDK internal type for
   // wrapping VecObject) without the exact pathway being super
   // obvious.
   //
   // In the model world a VecObject is a Values::VecObject::T.
   topic <- soroban_events_fresh_topic "contract_event.topic" heap;
   let topic_mir = soroban_value_to_mir smi topic;

   // get a fresh value
   // XXX: we should assert it's valid
   val <- mir_fresh_cryptol_var "events.publish.val" {| Values::RawT |};
   let val_mir = soroban_value_to_mir smi val;

   // bind the ghost state
   soroban_hostheap_assert_state heap;
   soroban_events_assert_state elog;

   // (XXX (saw): if one of these is a Term rather than MIRTerm, saw
   // prints a type error for the whole list rather than for the first
   // mismatched element.)
   mir_execute_func [self, topic_mir, val_mir];

   // update the event log
   let elog' = {{ EventLog::add elog topic val }};

   // assert the updated ghost state
   // (the heap doesn't change)
   soroban_hostheap_assert_state heap;
   soroban_events_assert_state elog';

   // returns the SDK Void value, wrapped in Result
   return_ok smi {{ Values::unit }};
};

/*
 * Construct the "overrides" (checked or admitted SAW theorems, in
 * this case admitted) for the SDK storage interface.
 */
let make_events_overrides (smi : SorobanMIRItems) mod features = do {
   if string_list.elem "events" features then do {
      event_spec <- mir_unsafe_assume_spec mod
         "soroban_sdk::env::{impl#12}::contract_event"
         (contract_event_spec smi);
      return [event_spec];
   }
   else
      return [];
};


////////////////////////////////////////////////////////////
// verify

/*
 * Args passed to verify
 */
typedef SorobanVerifyArgs = {
  fun : String,
  overrides : [MIRSpec],
  path_sat : Bool,
  spec : MIRSetup (),
  proof : ProofScript ()
};

/*
 * Hook for running verification
 */
let soroban_verify (soroban : SorobanAPI) (args : SorobanVerifyArgs) =
   mir_verify soroban.mod args.fun (concat soroban.sdk_overrides args.overrides)
        args.path_sat args.spec args.proof;

/*
 * Hook for assuming a specification instead
 * (intentionally has the same signature, even though some of it
 * isn't used)
 */
let soroban_assume (soroban : SorobanAPI) (args : SorobanVerifyArgs) =
   mir_unsafe_assume_spec soroban.mod args.fun args.spec;


////////////////////////////////////////////////////////////
// init

/*
 * Function to initialize the stuff in here.
 *
 * mod is the results of mir_load_module on the linked_mir.json file
 * containing the stuff we're trying to verify.
 *
 * The features list is a list of arbitrary strings naming things the
 * rust code is using; it prevents us from looking for MIR symbols
 * that don't exist. FUTURE: it should be a list of an enum type...
 */
let soroban_init (mod : MIRModule) (features : [String]) : TopLevel SorobanAPI = do {

   let feat_implies feats (x, y) =
      if string_list.elem x feats then concat [y] feats else feats;

   let features = list.foldl feat_implies features [
      ("logging", "void_val"),
      ("storage", "bool_val"),
      ("storage", "void_val"),
      ("symbol", "maybe_env")
   ];

   let smi = make_soroban_mir_items mod features;

   storage_overrides <- make_storage_overrides smi mod features;
   hostvalue_overrides <- make_hostvalue_overrides smi mod features;
   logging_overrides <- make_logging_overrides smi mod features;
   events_overrides <- make_events_overrides smi mod features;

   // note: "concat" is what's usually called append
   let sdk_overrides = concat
       (concat hostvalue_overrides storage_overrides)
       (concat logging_overrides events_overrides);

   return {
      mod = mod,
      smi = smi,
      sdk_overrides = sdk_overrides
   };
};
