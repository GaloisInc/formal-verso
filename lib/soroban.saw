enable_experimental;

include "list.saw";

/*
 * Load the cryptol modules.
 */

Util <- cryptol_load "Util.cry";
Option <- cryptol_load "Option.cry";
Values <- cryptol_load "Values.cry";
Store <- cryptol_load "Store.cry";


////////////////////////////////////////////////////////////
// MIR symbols

/*
 * Symbols extracted from the MIR
 */
typedef SorobanMIRItems = {
   // non-soroban
   InfallibleType : (() -> MIRAdt),
   ResultInfallibleType : (MIRType -> MIRAdt),

   // from the soroban_env_guest crate
   GuestType : (() -> MIRAdt),
   GuestVal : (() -> MIRValue),

   // from the soroban_sdk crate
   EnvType : (() -> MIRAdt),
   EnvVal : (() -> MIRValue),
   MaybeEnvType : (() -> MIRAdt),
   MaybeEnvVal : (() -> MIRValue),
   StorageType : (() -> MIRAdt),
   StorageVal : (() -> MIRValue),
   SymbolType : (() -> MIRAdt),

   // from the soroban_env_common crate
   BoolType : (() -> MIRAdt),
   U32ValType : (() -> MIRAdt),
   RawValType : (() -> MIRAdt),
   SymbolValType : (() -> MIRAdt),
   VoidType : (() -> MIRAdt)
};

let make_soroban_mir_items mod features : SorobanMIRItems =
   /*
    * Tools for looking up stuff in the MIR.
    */
   let find adt_name =
     let adt = mir_find_adt mod adt_name [] in
     \() -> adt
   in
   let find_when feat adt_name =
     if string_list.elem feat features then
       find adt_name
     else
       \() -> run (fail (str_concats [
         "Feature \"", feat, "\" is required for type ", adt_name
       ]))
   in

   /*
    * Bind handles for various SDK types.
    */

   // non-soroban
   let InfallibleType = find "core::convert::Infallible" in
   let ResultInfallibleType (t : MIRType) =
      mir_find_adt mod "core::result::Result" [t, mir_adt (InfallibleType ())]
   in

   // from the soroban_env_guest crate
   let GuestType = find "soroban_env_guest::guest::Guest" in

   // from the soroban_sdk crate
   let EnvType = find "soroban_sdk::env::Env" in
   let MaybeEnvType = find_when "maybe_env" "soroban_sdk::env::MaybeEnv" in
   let StorageType = find_when "storage" "soroban_sdk::storage::Storage" in
   let SymbolType = find_when "symbol" "soroban_sdk::symbol::Symbol" in

   // from the soroban_env_common crate
   let BoolType = find_when "bool_val" "soroban_env_common::raw_val::Bool" in
   let U32ValType = find_when "u32_val" "soroban_env_common::num::U32Val" in
   let RawValType = find "soroban_env_common::raw_val::RawVal" in
   let SymbolValType = find_when "symbol" "soroban_env_common::symbol::Symbol" in
   let VoidType = find_when "void_val" "soroban_env_common::raw_val::Void" in

   let GuestVal () =
     mir_struct_value (GuestType ()) [] in
   let EnvVal () =
     mir_struct_value (EnvType ()) [GuestVal ()] in
   let MaybeEnvVal () =
     mir_struct_value (MaybeEnvType ()) [GuestVal ()] in
   let StorageVal () =
     mir_struct_value (StorageType ()) [EnvVal ()] in

   {
      InfallibleType = InfallibleType,
      ResultInfallibleType = ResultInfallibleType,

      // from the soroban_env_guest crate
      GuestType = GuestType,
      GuestVal = GuestVal,

      // from the soroban_sdk crate
      EnvType = EnvType,
      EnvVal = EnvVal,
      MaybeEnvType = MaybeEnvType,
      MaybeEnvVal = MaybeEnvVal,
      StorageType = StorageType,
      StorageVal = StorageVal,
      SymbolType = SymbolType,

      // from the soroban_env_common crate
      BoolType = BoolType,
      U32ValType = U32ValType,
      RawValType = RawValType,
      SymbolValType = SymbolValType,
      VoidType = VoidType
   };


////////////////////////////////////////////////////////////
// interfacing types

typedef SorobanSpecAPI = {

  storage : {
    state : (Term /* Store */ -> MIRSetup ()),
    has : (Term /* Store */ -> Term /* k */ -> Term /* Bit */),
    get : (Term /* Store */ ->
      Term /* k */ -> Type /* = v */ -> Term /* Option (Option v) */),
    set : (Term /* Store */ ->
      Term /* k */ -> Term /* v */ -> Term /* Store */)
  },

  fresh : (String -> Type -> MIRSetup Term),

  mir_value : SorobanMIRItems,
  to_mir_value : (Term -> MIRValue),
  to_mir_type : (Type -> MIRType)

};

/*
 * Args passed to verify
 */
typedef SorobanVerifyArgs = {
  fun : String,
  overrides : [MIRSpec],
  path_sat : Bool,
  spec : MIRSetup (),
  proof : ProofScript ()
};

/*
 * Material returned by the init function for use by the actual specs:
 *    - references to MIR symbols from the SDK
 *    - spec wrapper function
 *    - verify wrapper function
 *    - assume wrapper function
 */
typedef SorobanAPI = {
  adt : SorobanMIRItems,
  spec : (String -> (SorobanSpecAPI -> MIRSetup ()) -> MIRSetup ()),
  verify : (SorobanVerifyArgs -> TopLevel MIRSpec),
  assume : (SorobanVerifyArgs -> TopLevel MIRSpec)
};


////////////////////////////////////////////////////////////
// SDK value interface

/*
 * Hook for dynamic type dispatch on the value types.
 *
 * This should really be module-private if there were such a thing.
 */
let type_eq (t1 : Type) (t2 : Type) : Bool =
   let s1 = show t1 in
   let s2 = show t2 in
   eval_bool {{ Util::lenPolyEq s1 s2 }};

/*
 * Check if a value of a value type is actually a valid value of
 * that type. In theory, we shouldn't ever attach types to invalid
 * values; we shouldn't ever construct any and potentially-garbage
 * values from outside should appear first as Values::Raw and get
 * checked before being converted to a specific value type.
 *
 * However, the Soroban SDK rust code plays fast and loose with
 * unsafe casts and we want to interoperate with it as much as
 * possible.
 *
 * The real type is:
 *    soroban_value_valid : (t : Type) -> t -> Bit
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_valid (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_valid }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_valid }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_valid }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_valid }}
   else if type_eq t {| Values::RawT |} then
      {{ Values::raw_valid }}
   else if type_eq t {| Store::T |} then
      // XXX: this gets passed here, but shouldn't be. ignore it for now
      // (this logic is for value types!)
      {{ \_ -> True }}
   else
      run (fail (str_concat (show t) " has no validity predicate"));

/*
 * Generate a fresh var of the requested value type.
 *
 * Note: only for value types.
 *
 * Note: we used to cons the name of the current spec onto the name
 * passed in. We don't do that any more because it requires all kinds
 * of contortions to remember the name in a useful way.
 */
let soroban_value_fresh (name : String) (t : Type) : MIRSetup Term = do {
   //let name' = str_concats [spec_name, "::", name];
   x <- mir_fresh_cryptol_var name t;
   let t_valid = soroban_value_valid t;
   mir_assert {{ t_valid x }};
   return x;
};

/*
 * Convert from a specific value type to Values::Raw::T.
 * Value types only.
 *
 * The real type is:
 *    soroban_value_to_raw : (t : Type) -> t -> Values::Raw::T
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_to_raw (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_to_raw }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_to_raw }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_to_raw }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_to_raw }}
   else
      run (fail (str_concat (show t) " cannot be converted to Raw"));

/*
 * Convert from a Values::Raw::T to a specific value type
 * (type is passed as the first argument)
 *
 * Returns None if the raw value is not actually a value
 * of the right type. Crashes if the type is wrong.
 *
 * The real type is:
 *    soroban_value_from_raw : (t : Type) -> Values::Raw::T -> Option::T t
 *
 * What's here returns a Cryptol function from Values.
 */
let soroban_value_from_raw (t : Type) : Term =
   if type_eq t {| Values::VoidT |} then
      {{ Values::void_from_raw }}
   else if type_eq t {| Values::BoolT |} then
      {{ Values::bool_from_raw }}
   else if type_eq t {| Values::U32T |} then
      {{ Values::u32_from_raw }}
   else if type_eq t {| Values::SymbolT |} then
      {{ Values::symbol_from_raw }}
   else
      run (fail (str_concat (show t) " cannot be converted from Raw"));


////////////////////////////////////////////////////////////
// init

/*
 * Function to initialize the stuff in here.
 *
 * Arguments are:
 *    mod : MirModule
 *    features : [String]
 *
 * mod is the results of mir_load_module on the linked_mir.json file
 * containing the stuff we're trying to verify.
 *
 * The features list is a list of arbitrary strings naming things the
 * rust code is using; it prevents us from looking for MIR symbols
 * that don't exist.
 */
soroban_init <- do {

  // XXX this is redundant and should be removed
  Util <- cryptol_load "Util.cry";

  /*
   * I'm not sure what this layer of indirection buys us.
   */

  let soroban_init (mod : MIRModule) (features : [String])
  : TopLevel SorobanAPI = do {

    state <- do {
      storage <- declare_ghost_state "Soroban::storage";
      return {
        storage = storage
      };
    };

    let feat_implies feats (x, y) =
      if string_list.elem x feats then concat [y] feats else feats;

    let features = list.foldl feat_implies features [
      ("storage", "bool_val"),
      ("storage", "void_val"),
      ("symbol", "maybe_env")
    ];

    let soroban_adt : SorobanMIRItems = make_soroban_mir_items mod features;


    /*
     * XXX this should be removed
     */
    let mir_value = soroban_adt;

    /*
     * Convert a value of a value type (recall the value types are
     * Cryptol types and have Cryptol values) to a mir_term.
     *
     * The MIR term we want is the corresponding tree of constructors
     * from the Rust side. There are two ways to do this: we can
     * extract the semantic value from the Cryptol term (e.g. unit,
     * True, False, 131, "hello", or whatever), convert that to its
     * Rust/MIR form, then create calls to the corresponding chain of
     * Rust constructors. Or, we can take advantage of having modeled
     * the internal representation used on the Rust side to just
     * extract the internal representation and transfer that across.
     *
     * There are at least three reasons to prefer the latter:
     *    - the internal representation is a u64 and is therefore
     *      easily moved across;
     *    - we can construct calls to arbitrary Rust functions if
     *      needed, but using them in spec-level logic is at least
     *      problematic (not sure whether it's allowed at all);
     *    - when we get to supporting object-style values, the
     *      external pointer part can just be pushed across as part
     *      of the u64 and we don't need to process the referent.
     *
     * In fact, I think this is why the Cryptol-level value logic was
     * built to match the internals of the Rust value logic.
     *
     * Ergo, the way this works is:
     *    - for types that aren't Values::Raw::T, recurse on the raw
     *      value and pass the results to the corresponding Rust
     *      constructor;
     *    - for Values::Raw::T, extract the bits of the representation
     *      and pass that to the Rust constructor.
     *
     * Note that for the latter case we need to fetch the bits
     * directly rather than calling the Cryptol-level accessor
     * function. Otherwise SAW loses track of the value when doing
     * override matching and the specs we produce don't work. See
     * saw-script #2035.
     *
     * For reasons I don't understand this seems to apply only to
     * the raw layer; the accessor functions for the wrapper types
     * seem to work ok.
     */
    rec to_mir_value x =
      let t = type x in
      if type_eq t {| Values::VoidT |} then
        mir_struct_value (soroban_adt.VoidType ()) [
          to_mir_value {{ Values::void_to_raw x }}
        ]
      else if type_eq t {| Values::BoolT |} then
        mir_struct_value (soroban_adt.BoolType ()) [
          to_mir_value {{ Values::bool_to_raw x }}
        ]
      else if type_eq t {| Values::U32T |} then
        mir_struct_value (soroban_adt.U32ValType ()) [
          to_mir_value {{ Values::u32_to_raw x }}
        ]
      else if type_eq t {| Values::SymbolT |} then
        mir_struct_value (soroban_adt.SymbolType ()) [
          mir_value.MaybeEnvVal (),
          mir_struct_value (soroban_adt.SymbolValType ()) [
            to_mir_value {{ Values::symbol_to_raw x }}
          ]
        ]
      else if type_eq t {| Values::RawT |} then
        mir_struct_value (soroban_adt.RawValType ()) [
          // XXX: can't do this, it makes SAW unable to match specs
          //mir_term {{ Values::raw_get_payload x }}
          mir_term {{ x.bits }}
        ]
      else
        run (fail (str_concat (show t) " cannot be converted to a MIR value"));

    /*
     * Extract the MIR-level type for type T.
     *
     * This function is the type-level version of to_mir_value, and
     * uses the same types as returned by to_native.
     *
     * XXX: except that's wrong... and we maybe need name reform,
     * because there's _three_ types for any given Soroban value:
     *    - the Rust type, which is something out of the MIR;
     *    - the Cryptol type, which matches the structure of the MIR type;
     *    - the native SAW and/or Cryptol representation of the value;
     *
     * and I think we're playing fast and loose with the distinction
     * between the last two, which is bad.
     */
    let to_mir_type t =
      if type_eq t {| Values::VoidT |} then
        mir_adt (soroban_adt.VoidType ())
      else if type_eq t {| Values::BoolT |} then
        mir_adt (soroban_adt.BoolType ())
      else if type_eq t {| Values::U32T |} then
        mir_u32
      else if type_eq t {| Values::SymbolT |} then
        mir_adt (soroban_adt.SymbolType ())
      else if type_eq t {| Values::RawT |} then
        mir_adt (soroban_adt.RawValType ())
      else
        run (fail (str_concat (show t) " cannot be converted to MIRType"));

    /*
     * Spec for the storage interface.
     *
     * For now at least the Cryptol-level store is written
     * purely in terms of Values::Raw::T and the type wrapping happens
     * here. It's possible that should change, but we'll see.
     */
    let spec_storage = {

      state = \store -> do {
        mir_ghost_value state.storage store;
      },

      has = \store k ->
        let k_to_raw = soroban_value_to_raw (type k) in
        {{ Store::has store (k_to_raw k) }},

      get = \store k tv ->
        let k_to_raw = soroban_value_to_raw (type k) in
        let v_from_raw = soroban_value_from_raw tv in
        {{ Option::fmap
            (Store::get store (k_to_raw k))
            v_from_raw }},

      set = \store k v ->
        let k_to_raw = soroban_value_to_raw (type k) in
        let v_to_raw = soroban_value_to_raw (type v) in
        {{ Store::set store (k_to_raw k) (v_to_raw v) }}

    };

    /*
     * Wrapper for contract specs.
     */
    let soroban_spec spec_name spec = do {

      let (api : SorobanSpecAPI) = {

        storage = spec_storage,

        /*
         * Generate a fresh var of the requested value type.
         */
        fresh = soroban_value_fresh,

        mir_value = mir_value,
        to_mir_value = to_mir_value,
        to_mir_type = to_mir_type

      };

      spec api;

    };

    let sdk_assume feat name spec =
      if string_list.elem feat features then
        list.sequence [mir_unsafe_assume_spec mod name (soroban_spec name spec)]
      else
        return [];

    /*
     * Construct the "overrides" (checked or admitted SAW theorems)
     * for the SDK interfaces.
     */
    sdk_overridess <-

      let return_ok (x : Term) : MIRSetup () =
        mir_return
          (mir_enum_value
            (soroban_adt.ResultInfallibleType (to_mir_type (type x)))
            "Ok"
            [to_mir_value x])
      in

      list.sequence [

        sdk_assume "storage" "soroban_sdk::env::{impl#12}::has_contract_data"
          (\(s : SorobanSpecAPI) -> do {

            store <- mir_fresh_cryptol_var "storage.has.store" {| Store::T |};

            self <- mir_alloc (mir_adt (soroban_adt.EnvType ()));
            mir_points_to self (s.mir_value.EnvVal ());

            k <- s.fresh "storage.has.k" {| Values::RawT |};

            s.storage.state store;

            mir_execute_func [self, s.to_mir_value k];

            s.storage.state store;

            return_ok {{ Values::bool_from_native (Store::has store k) }};

          }),

        sdk_assume "storage" "soroban_sdk::env::{impl#12}::get_contract_data"
          (\(s : SorobanSpecAPI) -> do {

            store <- mir_fresh_cryptol_var "storage.get.store" {| Store::T |};

            self <- mir_alloc (mir_adt (soroban_adt.EnvType ()));
            mir_points_to self (s.mir_value.EnvVal ());

            k <- s.fresh "storage.get.k" {| Values::RawT |};

            mir_precond {{ Store::has store k }};
            s.storage.state store;

            mir_execute_func [self, s.to_mir_value k];

            s.storage.state store;

            return_ok {{ (Store::get store k).value }};

          }),

        sdk_assume "storage" "soroban_sdk::env::{impl#12}::put_contract_data"
          (\(s : SorobanSpecAPI) -> do {

            store <- mir_fresh_cryptol_var "storage.put.store" {| Store::T |};

            self <- mir_alloc (mir_adt (soroban_adt.EnvType ()));
            mir_points_to self (s.mir_value.EnvVal ());

            k <- s.fresh "storage.put.k" {| Values::RawT |};
            v <- s.fresh "storage.put.v" {| Values::RawT |};

            s.storage.state store;

            mir_execute_func [self, s.to_mir_value k, s.to_mir_value v];

            s.storage.state {{ Store::set store k v }};

            return_ok {{ Values::unit }};

          })

      ];
    let sdk_overrides = list.concats sdk_overridess;

    /*
     * Hook for running verification
     */
    let soroban_verify (args : SorobanVerifyArgs) =
      mir_verify mod args.fun (concat sdk_overrides args.overrides)
        args.path_sat args.spec args.proof;

    /*
     * Hook for assuming a specification instead
     * (intentionally has the same signature, even though some of it
     * isn't used)
     */
    let soroban_assume (args : SorobanVerifyArgs) =
      mir_unsafe_assume_spec mod args.fun args.spec;

    return {
      adt = soroban_adt,
      spec = soroban_spec,
      verify = soroban_verify,
      assume = soroban_assume
    };

  };

  return soroban_init;

};
