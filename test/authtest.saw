import "../lib/Values.cry";
import "../lib/Auth.cry";

/*
 * Some correctness property checks for Auth.cry.
 *
 * The lemma statements in the comments here use Coq notation because
 * SAW doesn't have adequate notation of its own.
 *
 * Note that these are checks of the form pre -> ~post, so "Unsat"
 * means QED.
 *
 * The ones that don't terminate are disabled. To try one, comment out
 * the "let _ = \() ->" line.
 */


/*
 * argbundle_of_vecobj produces a valid ArgBundle.
 *
 * forall heap vec,
 *    vecobj_valid_with_heap vec heap ->
 *    argbundle_valid (argbundle_of_vecobj heap vec)
 */
let _ = \() ->
sat_print (w4_unint_z3 []) {{
   \heap vec -> (
      vecobj_valid_with_heap vec heap &&
      ~ (argbundle_valid (argbundle_of_vecobj heap vec))
   )
}};

/*
 * argbundle_of_list produces a valid ArgBundle.
 *
 * forall vals,
 *    argbundle_valid (argbundle_of_list vals)
 *
 * XXX: has to hardwire the number of args, which isn't very general.
 */
sat_print (w4_unint_z3 []) {{
   \(vals: [3] RawT) -> (
      ~ (argbundle_valid (argbundle_of_list vals))
   )
}};

/*
 * authorize preserves validity of the Auth
 *
 * forall auth addr nodes,
 *    valid auth ->
 *    addressobj_valid addr ->
 *    (forall (contract, args),
 *       In (contract, args) nodes ->
 *       symbol_valid contract /\
 *       argbundle_valid args) ->
 *    valid (authorize auth addr nodes)
 *
 * For now we're limited to one node, so do that.
 */
let _ = \() ->
sat_print (w4_unint_z3 []) {{
   \auth addr (nodes: [1] (SymbolT, ArgBundle)) -> (
      valid auth &&
      addressobj_valid addr &&
      //nodelist_valid nodes &&
      symbol_valid ((nodes ! 0).0) &&
      argbundle_valid ((nodes ! 0).1) &&
      ~ (valid (authorize auth addr nodes))
   )
}};

/*
 * check_fragment preserves validity of the Auth
 *
 * forall heap auth addr args,
 *    valid auth ->
 *    addressobj_valid addr ->
 *    argbundle_valid args ->
 *    (let (auth', ok) := check_fragment heap auth addr in valid auth')
 */
let _ = \() ->
sat_print (w4_unint_z3 []) {{
   \heap auth addr args -> (
      valid auth &&
      addressobj_valid addr &&
      argbundle_valid args &&
      ~ (valid auth'
          where (auth', ok) = check_fragment heap auth addr args
      )
   )
}};
